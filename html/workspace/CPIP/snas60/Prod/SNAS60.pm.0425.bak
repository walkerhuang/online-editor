#
# $Copyright: Copyright (c) 2014 Symantec Corporation.
# All rights reserved.
#
# THIS SOFTWARE CONTAINS CONFIDENTIAL INFORMATION AND TRADE SECRETS OF
# SYMANTEC CORPORATION.  USE, DISCLOSURE OR REPRODUCTION IS PROHIBITED
# WITHOUT THE PRIOR EXPRESS WRITTEN PERMISSION OF SYMANTEC CORPORATION.
#
# The Licensed Software and Documentation are deemed to be commercial
# computer software as defined in FAR 12.212 and subject to restricted
# rights as defined in FAR Section 52.227-19 "Commercial Computer
# Software - Restricted Rights" and DFARS 227.7202, "Rights in
# Commercial Computer Software or Commercial Computer Software
# Documentation", as applicable, and any successor regulations. Any use,
# modification, reproduction release, performance, display or disclosure
# of the Licensed Software and Documentation by the U.S. Government
# shall be solely in accordance with the terms of this Agreement.  $
#
use strict;

package Prod::SNAS60::Common;
@Prod::SNAS60::Common::ISA = qw(Prod::SFCFSHA61::Common);

sub responsefile_prestart_config {
    my ($prod) = @_;
    my ($ret,$msg,$cpic);
    $cpic=Obj::cpic();
    $ret = $prod->op_nic_hostname();
    if ($ret == 0 || $ret == 2) {
        $msg = Msg::new("NIC detecting error, please double check the enviroment.");
        $msg->error();
        $cpic->edr_completion();
        return; 
    }
    $prod->perform_task('responsefile_prestart_config');
    return;
}

sub cli_prod_option {
    my $prod = shift;
    $prod->perform_task('cli_prod_option');
    $prod->opt_addnode() if (Cfg::opt('addnode'));
}

sub opt_addnode {
    my $prod = shift;
    my $vcs = $prod->prod('VCS61');
    for my $sub (qw(addnode_messages addnode_get_cluster addnode_get_newnode addnode_compare_systems 
                    addnode_preconfig_newnode addnode_config_snas addnode_configure_heartbeat 
                    addnode_configure_cluster addnode_start_cluster addnode_poststart addnode_completion))
                    
    {
        if ($prod->can($sub)) {
            $prod->$sub();
        } else {
            $vcs->$sub();
        }     
    }
    return;
}

package Prod::SNAS60::AIX;
@Prod::SNAS60::AIX::ISA = qw(Prod::SNAS60::Common);

package Prod::SNAS60::HPUX;
@Prod::SNAS60::HPUX::ISA = qw(Prod::SNAS60::Common);

package Prod::SNAS60::Linux;
@Prod::SNAS60::Linux::ISA = qw(Prod::SNAS60::Common);

package Prod::SNAS60::RHEL5x8664;
@Prod::SNAS60::RHEL5x8664::ISA = qw(Prod::SNAS60::Linux);

package Prod::SNAS60::RHEL6x8664;
@Prod::SNAS60::RHEL6x8664::ISA = qw(Prod::SNAS60::Linux);

sub init_padv {
    my $prod=shift;
    $prod->{name}=Msg::new("Symantec Storage NAS")->{msg};
    $prod->{prod}='SNAS';
    $prod->{abbr}='SNAS';
    $prod->{proddir}='symantec_storage_nas';
    $prod->{menu_options}=['Veritas Volume Replicator','Global Cluster Option'];
    $prod->{eula}='EULA_SFHA_Ux_6.1.pdf';
    $prod->{allpkgs}=[ qw(VRTSglm61 VRTScavf61 VRTSgms61 VRTSdbms330 SYMCsnas60) ];
    $prod->{minpkgs}=[ qw(VRTSglm61 VRTScavf61 VRTSdbms330 SYMCsnas60) ];
    $prod->{recpkgs}=[ qw(VRTSglm61 VRTScavf61 VRTSgms61 VRTSdbms330 SYMCsnas60) ];

    $prod->{lic_names}=['Storage Foundation for Cluster File System'];

    $prod->{installscript_prod}='SNAS60';
    $prod->{installscript_name}='SNAS';
    $prod->{mainpkg}='VRTScavf61';
    $prod->{installallpkgs} = 1;

    $prod->{extra_mainpkgs}=[ qw(VRTSvxvm61 VRTSvxfs61 VRTSvcs61 VRTSllt61 VRTSgab61 VRTSvxfen61 VRTSvcsag61)];

    $prod->{logdir}='/opt/SYMCsnas/log';
    $prod->{scriptsdir}='/opt/SYMCsnas/scripts';
    $prod->{sysscriptsdir}='/opt/SYMCsnas/scripts/system';
    $prod->{storscriptsdir}='/opt/SYMCsnas/scripts/storage';
    $prod->{libscriptsdir}='/opt/SYMCsnas/scripts/lib';
    $prod->{installerdir}='/opt/SYMCsnas/install/image_install';
    $prod->{nicconf}->{filepath} = "/opt/SYMCsnas/conf/";
    $prod->{nicconf}->{nodefilepath} = "/opt/SYMCsnas/nodeconf/";
    $prod->{nicconf}->{physicalipfile}="/opt/SYMCsnas/conf/net_pip_list.conf";
    $prod->{nicconf}->{publicdevicefile}="/opt/SYMCsnas/conf/net_pub_dev_list.conf";
    $prod->{nicconf}->{privatedevicefile}="/opt/SYMCsnas/conf/net_priv_dev.conf";
    $prod->{nicconf}->{privateipfile}="/opt/SYMCsnas/conf/net_priv_ip_list.conf";
    $prod->{nicconf}->{vipfile}="/opt/SYMCsnas/conf/net_vip_list.conf";
    $prod->{nicconf}->{vipdevicefile}="/opt/SYMCsnas/conf/net_vip_dev_list.conf";
    $prod->{nicconf}->{consoleipfile}="/opt/SYMCsnas/conf/net_console_ip.conf";
    $prod->{nicconf}->{consoledevfile}="/opt/SYMCsnas/conf/net_console_dev.conf";
    $prod->{nicconf}->{nasinstallconf}="/opt/SYMCsnas/nodeconf/nasinstall.conf";
    $prod->{nicconf}->{udevconffile}="/etc/udev/rules.d/70-persistent-net.rules";
    $prod->{nicconf}->{globalroutes}="/opt/SYMCsnas/conf/net_globalroutes.conf";
    $prod->{nicconf}->{rcscriptpath}="/etc/rc.d/rc.local";
    $prod->{nicconf}->{rcscript}="/tmp/nicscript.sh";
    $prod->{clish}->{clishhomepath}="/home/clish";
    $prod->{clish}->{bashpath}="/bin/bash";
    $prod->{clish}->{clishpath}="/opt/SYMCsnas/clish/bin/clish";
    $prod->{clish}->{supporthomepath}="/home/support";
    $prod->{netproto}="ipv4";
    $prod->{netprotovip}="ipv4";
    $prod->{netprotoipv4}="ipv4";
    $prod->{netprotoipv6}="ipv6";
    $prod->{hostsfile}='/etc/hosts';
    $prod->{fatal_error_key}="STOP";
    $prod->{ip_error_key}="IPERROR";
    $prod->{mode}->{master}="new";
    $prod->{mode}->{slave}="join";
    $prod->{minimum_pub_nic_num}=1;
    $prod->{mininum_priv_nic_num}=1;
    $prod->{max_priv_nic_num}=2;
    $prod->{priviparr}=['172.16.0.3',
                           '172.16.0.4',
                           '172.16.0.5',
                           '172.16.0.6',
                           '172.16.0.7',
                           '172.16.0.8',
                           '172.16.0.9',
                           '172.16.0.10',
                           '172.16.0.11',
                           '172.16.0.12',
                           '172.16.0.13',
                           '172.16.0.14',
                           '172.16.0.15',
                           '172.16.0.16',
                           '172.16.0.17',
                           '172.16.0.18',
                           '172.16.0.19'];

    $prod->{privateipnetmask}="255.255.255.0";
    $prod->{store_release_imgs}{config_file} = "/opt/VRTS/.install_pref";
    $prod->{privnic_prefix} = "priveth";
    $prod->{pubnic_prefix} = "pubeth";
    $prod->{gui_lib_dir} = '/opt/SYMCsnas/gui/third_party_libs';
    $prod->{gui_install_dir} = '/opt/SYMCsnas/gui/install';
    $prod->{gui_rpm_dir} = 'gui_rpms';
    return ;
}

sub set_pkgs {
    my $prod = shift;
    my($category,@categories);

    $prod->SUPER::set_pkgs();
    @categories=qw(minpkgs recpkgs allpkgs);
    for my $category (@categories) {
        $prod->{$category}=EDRu::arrdel($prod->{$category},'VRTSodm61', 'VRTSob34');
    }
    return $prod->{allpkgs};
}

sub preinstall_sys {
    my ($prod, $sys) = @_;

    $prod->SUPER::preinstall_sys($sys);
    $prod->get_imgs_stored_location_sys($sys);
    $prod->check_img_space_sys($sys);
    return;
}

#1. read config file and init $sys->{store_release_imgs}
#2. check if imgs already stored on system. if not stored, prepare to store them after installation.
sub get_imgs_stored_location_sys {
    my ($prod, $sys) = @_;
    my ($cpic, $rel, $repository_path);
    my ($base_path, $base_version, $mr_path, $mr_version, $hf_path, $hf_version, $dest_path);
    $cpic = Obj::cpic();

    $prod->init_preference_sys($sys);
    $repository_path = $prod->get_repository_on_sys($sys);
    $rel = $cpic->rel();
    #get base release image
    if ($rel->{type} =~ /B/) {
        $base_path = Cfg::opt('base_path') || $cpic->{mediapath};
        $base_version = $prod->major_vers($rel->{vers});
        $dest_path = "ga/images/SSNAS/$base_version";
        if (!$prod->img_stored_on_sys($sys, "$repository_path/$dest_path")) {
            $sys->{store_release_imgs}{base_img}{from} = $base_path;
            $sys->{store_release_imgs}{base_img}{to} = $dest_path;
        }
        $sys->{store_release_imgs}{"InstalledBase"} = $base_version;
        $sys->{store_release_imgs}{"InstalledMR"} = "";
        $sys->{store_release_imgs}{"InstalledHF"} = "";
    }
    #get mr release image
    if ($rel->{type} =~ /M/) {
        $mr_path = $cpic->{mediapath};
        $mr_version = $cpic->maintenance_release();
        $dest_path = "patch/images/SSNAS/$mr_version";
        if (!$prod->img_stored_on_sys($sys, "$repository_path/$dest_path")) {
            $sys->{store_release_imgs}{mr_img}{from} = $mr_path;
            $sys->{store_release_imgs}{mr_img}{to} = $dest_path;
        }
        $sys->{store_release_imgs}{"InstalledMR"} = $mr_version;
        $sys->{store_release_imgs}{"InstalledHF"} = "";
    }
    #get hotfix release images
    if ($rel->{type} =~ /H/) {
        $hf_path = Cfg::opt("hotfix_path") || $cpic->{mediapath};
        $hf_version = $rel->{vers};
        $dest_path =  "hotfix/images/SSNAS/$hf_version";
        if (!$prod->img_stored_on_sys($sys, "$repository_path/$dest_path")) {
            $sys->{store_release_imgs}{hf_img}{from} = $hf_path;
            $sys->{store_release_imgs}{hf_img}{to} = $dest_path;
        }
        $sys->{store_release_imgs}{"InstalledHF"} = $hf_version;
    }
    return 1;
}

sub init_preference_sys {
    my ($prod, $sys) = @_;
    my ($content, $file, %preference_hash);
    unless($sys->exists($prod->{store_release_imgs}{config_file})) {
        $file = $prod->{store_release_imgs}{config_file};
        $preference_hash{"Repository"} = "/opt/VRTS/repository";
        $preference_hash{"StoreReleaseImages"} = "Y";
        $preference_hash{"InstalledBase"} = "";
        $preference_hash{"InstalledMR"} = "";
        $preference_hash{"InstalledHF"} = "";

        $content=JSON::to_json(\%preference_hash,{pretty=>1});

        $sys->writefile($content, $file);
    }
    $prod->read_preference_file_sys($sys);
    return 1;
}

sub read_preference_file_sys {
    my ($prod, $sys) = @_;
    my ($content, $preference_hash);
    my $file = $prod->{store_release_imgs}{config_file};

    if ($sys->exists($file)) {
        $content = $sys->catfile($file);
    } else {
        Msg::die("Reference file $file is not existed on $sys->{sys}")
    }

    $preference_hash = EDRu::eval_json($content);
    for my $key (keys %{$preference_hash}) {
        $sys->{store_release_imgs}{$key} = $preference_hash->{$key};
    }
    return 1;
}

sub update_preference_file_sys {
    my ($prod, $sys) = @_;
    my $preference_file = $prod->{store_release_imgs}{config_file};
    my $content;

    $content = JSON::to_json($sys->{store_release_imgs}, {pretty=>1});
    $sys->writefile($content, $preference_file);
    return 1;
}
#get the repository path forsys 
sub get_repository_on_sys {
    my ($prod, $sys) = @_;
    my $msg;
    if ($sys->{store_release_imgs}{"Repository"}) {
        return $sys->{store_release_imgs}{"Repository"};
    } else {
        $msg=Msg::new("Cannot find Repository directory on $sys->{sys}");
        $msg->die();
    }
    return 1;
}

sub major_vers {
    my ($prod, $vers) = @_;
    my @vfields = split(/\./m, $vers);
    my ($majorver, $padv);

    $vfields[0] =~ s/\D.*$//m;
    $vfields[0] += 0;
    $vfields[1] =~ s/\D.*$//m;
    $vfields[1] += 0;
    $majorver = join('.', $vfields[0], $vfields[1]);
    return $majorver;
}

#check if image is stored on sys:
#1. img_dir existed
#2. install* script existed under $img_dir
#3. ssn_img.tar is not eixsted under %img_dir
sub img_stored_on_sys {
    my ($prod, $sys, $img_dir) = @_;
    my $tmp_tar = "ssn_img.tar";
    my $msg;
    if ($sys->exists($img_dir) && ($sys->cmd("_cmd_ls $img_dir | _cmd_grep 'install*'"))) {
        if ($sys->exists("$img_dir/$tmp_tar")) {
            Msg::log("$img_dir/$tmp_tar is not removed after last installation. Assume img not existed on $sys->{sys}");
            return 0;
        }
        Msg::log("Img $img_dir existed on $sys->{sys}");
        return 1;
    }
    return 0;
}

sub del_obsoloted_img_sys {
    my ($prod, $sys) = @_;
    my ($installed_base, $installed_mr, $installed_hf, $repository_path);

    $installed_base = $sys->{store_release_imgs}{"InstalledBase"};
    $installed_mr = $sys->{store_release_imgs}{"InstalledMR"};
    $installed_hf = $sys->{store_release_imgs}{"InstalledHF"};
    $repository_path = $prod->get_repository_path($sys);

    #delete base imgs
    my $base_directory = "$repository_path/ga/images/SSNAS/";
    if ($sys->exists($base_directory)) {
        if ($installed_base) {
            $sys->cmd("cd $base_directory; _cmd_ls | _cmd_grep -v $installed_base | xargs _cmd_rmr ")
        } else {
            $sys->cmd("_cmd_rmr $base_directory/*")
        }
    }

    #delete mr imgs
    my $mr_directory = "$repository_path/patch/images/SSNAS/";
    if ($sys->exists($mr_directory)) {
        if ($installed_mr) {
            $sys->cmd("cd $mr_directory; _cmd_ls | _cmd_grep -v $installed_mr | xargs _cmd_rmr ")
        } else {
            $sys->cmd("_cmd_rmr $mr_directory/*")
        }
    }

    #delete hotfix images
    my $hotfix_directory = "$repository_path/hotfix/images/SSNAS/";
    if ($sys->exists($hotfix_directory)) {
        if ($installed_hf) {
            $sys->cmd("cd $hotfix_directory; _cmd_ls | _cmd_grep -v $installed_hf | xargs _cmd_rmr ")
        } else {
            $sys->cmd("_cmd_rmr $hotfix_directory/*")
        }
    }
    return 1;
}

sub get_repository_path {
    my ($prod, $sys) = @_;
    my $msg;
    if ($sys->{store_release_imgs}{"Repository"}) {
        return $sys->{store_release_imgs}{"Repository"};
    } else {
        $msg=Msg::new("Cannot find Repository directory on $sys->{sys}");
        $msg->die();
    }
    return 1;
}

#copy img from localsys to other node
sub copy_img_to_sys {
    my ($prod, $sys, $level) = @_;
    my ($localtmptarfile, $tmptarfile, $repdir, $syslist, $sysobj, $img_exist, $srcpath, $despath, $msg, $imgversion);
    my $localsys = Obj::edr()->{localsys};
    my $repository_path;
    my $tmp_tar = "ssn_img.tar";
    my $tmpdir = EDR::get('tmpdir');

    if ($level eq 'base') {
        $srcpath = $sys->{store_release_imgs}{base_img}{from};
        $despath = $sys->{store_release_imgs}{base_img}{to};
        $imgversion = $sys->{store_release_imgs}{"InstalledBase"};
    } elsif ($level eq 'mr') {
        $srcpath = $sys->{store_release_imgs}{mr_img}{from};
        $despath = $sys->{store_release_imgs}{mr_img}{to};
        $imgversion = $sys->{store_release_imgs}{"InstalledMR"};
    } elsif ($level eq 'hf') {
        $srcpath = $sys->{store_release_imgs}{hf_img}{from};
        $despath = $sys->{store_release_imgs}{hf_img}{to};
        $imgversion = $sys->{store_release_imgs}{"InstalledHF"};
    } else {
        Msg::log("level $level is not defined on $sys->{sys}");
        $msg = Msg::new("Store SNAS $imgversion image on $sys->{sys} failed. Pleaes contact vendor to store image after install accomplishment.");
        $sys->push_warning($msg);
        return;
    }

    $repository_path = $prod->get_repository_path($sys);
    $tmptarfile = "$repository_path/$despath/$tmp_tar";
    #make tar file on localsys
    $localtmptarfile = "$tmpdir/$level/$tmp_tar";
    if (!$sys->system1) {
        EDRu::wait_for_flag("make_tmp_tar_$level\_done");
    } else {
        EDRu::mkdir_local_nosys("$tmpdir/$level");
        $localsys->cmd("cd $srcpath; _cmd_tar -cvf $localtmptarfile *");
        EDRu::create_flag("make_tmp_tar_$level\_done");
    }

    if (!$sys->exists("$repository_path/$despath")) {
        $sys->cmd("_cmd_mkdir -p $repository_path/$despath");
    }

    #copy tar file to sys
    $localsys->copy_to_sys($sys,$localtmptarfile,$tmptarfile);

    #untar file on sys
    $sys->cmd("cd $repository_path/$despath; _cmd_tar -xvf $tmptarfile && _cmd_rmr $tmptarfile 2>/dev/null");
    if ($prod->img_stored_on_sys($sys, "$repository_path/$despath")) {
        $msg = Msg::new("Store SNAS $imgversion image on $sys->{sys} successfully");
        $sys->push_note($msg);
    } else {
        $msg = Msg::new("Store SNAS $imgversion image on $sys->{sys} failed. Pleaes contact vendor to store image after install accomplishment.");
        $sys->push_warning($msg);
    }
    return 1;
}

sub check_img_space_sys {
    my ($prod, $sys) = @_;
    my ($cpic, $free, $img_size, $img_path, $msg, $require_space);
    $cpic = Obj::cpic();
    $free = $cpic->volumespace_sys($sys, '/opt') || $cpic->volumespace_sys($sys, '/');

    if ($sys->{store_release_imgs}{base_img}) {
        $img_path = $sys->{store_reelase_img}{base_img}{from};
        $img_size += $sys->cmd("_cmd_du -sk $img_path");
    }
    if ($sys->{store_release_imgs}{mr_img}) {
        $img_path = $sys->{store_reelase_img}{mr_img}{from};
        $img_size += $sys->cmd("_cmd_du -sk $img_path");
    }
    if ($sys->{store_release_imgs}{hf_img}) {
        $img_path = $sys->{store_reelase_img}{hf_img}{from};
        $img_size += $sys->cmd("_cmd_du -sk $img_path");
    }

    $require_space = $img_size * 3;
    if ($free < $require_space) {
        $msg = Msg::new("Not enough space in /opt on system $sys->{sys}.");
        Msg::log("On $sys->{sys} only $free KB for /opt, requirement is $require_space KB");
        $sys->push_error($msg);
    }
    return 1;
}


sub cli_prestart_config_questions {
    my ($prod) = @_;
    my ($mode,$ret,$vcs,$msg,$cpic);
    $cpic=Obj::cpic();
    $vcs = $prod->prod('VCS61');

    $ret = $prod->op_nic_hostname();
    if ($ret == 0 || $ret == 2) {
        $msg = Msg::new("NIC detecting error, please double check the enviroment.");
        $msg->error();
        $cpic->edr_completion();  
        return; 
	}
    $ret = $prod->init_cfg_val();

    return 1 unless($vcs->prestart_config_common_questions);

    $prod->config_cluster();
#    $prod->config_management_console;
    return;
}

# configure cluster id and heartbeat links
sub config_cluster {
    my $prod = shift;
    my ($ayn,$cfg,$clus_id,$clus_name,$done,$help,$msg,$rhbn,$summary,$vcs_prod);
    my ($autocfg_failed);
    $cfg = Obj::cfg();
    $vcs_prod = $prod->prod('VCS61');
    $cfg->{vcs_allowcomms} = 1;
    $done = 0;
    $autocfg_failed = 0;
    $cfg->{snas_clustername} ||= 'snascluster';
    $cfg->{vcs_clustername} = $cfg->{snas_clustername};
    $clus_name = $cfg->{snas_clustername};

    $rhbn = $vcs_prod->auto_config_llt();
    while (!$done) {
        $rhbn = $vcs_prod->hb_config_option('autocfg_failed') if ($autocfg_failed);
        next if (EDR::getmsgkey($rhbn, 'back'));
        $cfg->{vcs_clusterid} = int(rand(65535)) if (!defined($cfg->{vcs_clusterid}));
        $clus_id = $cfg->{vcs_clusterid};
        if ($vcs_prod->check_clusterid($clus_id,$rhbn)) {
            $clus_id = $vcs_prod->config_clusterid($clus_id,$rhbn);
        }
        $msg = $vcs_prod->display_config_info($clus_name,$clus_id,$rhbn);
        $summary = $msg;
        if ($cfg->{autocfgllt} && $vcs_prod->num_hbnics($rhbn) == 1 && $vcs_prod->num_lopri_hbnics($rhbn) == 0) {
            Msg::n();
            $msg = Msg::new("The following warning was discovered on the systems:");
            $msg->bold;
            Msg::n();
            $msg = Msg::new("Only one LLT private link is available");
            $msg->print();
        }
        Msg::n();
        $msg = Msg::new("Is this information correct?");
        $help =Msg::new("Verification of the input");
        $ayn = $msg->ayny($help);
        if ($ayn eq 'Y') {
            $done=1;
            $summary->add_summary(1);
        } else {
            $autocfg_failed = 1;
            delete($cfg->{autocfgllt});
        }
    }
    unless (Cfg::opt('responsefile')) {
        $cfg->{vcs_clusterid}=$clus_id;
        $vcs_prod->set_hb_nics($rhbn, CPIC::get('systems'));
        $cfg->{vcs_clustername} = $cfg->{snas_clustername};
    }
    delete($cfg->{autocfgllt});

    $prod->ssh_com_setup(CPIC::get('systems'));

    return;
}

sub config_management_console {
    my $prod = shift;
    my ($ayn,$cfg,$done,$msg,$msg_str,$netm,$mcnic_ref,$prefix,$vcs,$vip);
    $cfg = Obj::cfg();
    return '' if (Cfg::opt('responsefile'));
    $vcs = $prod->prod('VCS61');
    Msg::title();
    $msg = Msg::new("The following data is required to configure the Management Console:\n");
    $msg->bold;
    $msg = Msg::new("\tA public NIC used by each system in the cluster");
    $msg->print;
    $msg = Msg::new("\tA Virtual IP address and netmask");
    $msg->printn;
    do {
        $mcnic_ref = $vcs->ask_publicnic();
        next if (EDR::getmsgkey($mcnic_ref,'back'));
        $vip = $vcs->ask_vip('');
        next if (EDR::getmsgkey($vip,'back'));
        $netm = $vcs->ask_netmask($vip,$$mcnic_ref{${$cfg->{systems}}[0]});
        next if (EDR::getmsgkey($netm,'back'));
        Msg::title();
        if ( EDRu::ip_is_ipv6($vip)) {
            $prefix = Msg::new("Prefix");
        } else {
            $prefix = Msg::new("NetMask");
        }
        $msg = Msg::new("Management Console configuration verification:\n");
        $msg->bold;
        $msg_str = $vcs->display_csgnic($mcnic_ref);
        $msg = Msg::new("\tIP: $vip\n");
        $msg_str .= $msg->{msg};
        $msg = Msg::new("\t$prefix->{msg}: $netm\n");
        $msg_str .= $msg->{msg};
        Msg::print($msg_str);
        $msg = Msg::new("Is this information correct?");
        $ayn = $msg->ayny;
        $done = 1 if ($ayn eq 'Y');
    } while (!$done);
    $vcs->store_nic($mcnic_ref,'vcs_mc_nic');
    $cfg->{vcs_mc_vip} = $vip;
    $cfg->{vcs_mc_netmask} = $netm;
    return;
}

sub op_nic_hostname {
    my $prod = shift;
    my ($msg,$output,$done,$sub,$msg,$ayn,$cpic,$flag,$ayn);
    $flag = 1;

    $output = $prod->preconfig_precheck();
    if ($output == 0) {
        $done = 1;
        do {
            $msg = Msg::new("The NIC names have been configured, do you want to reconfigure them?");
            $ayn = $msg->aynn;
            return 1 if ($ayn eq 'N');  
            $done = 0 if($ayn eq 'Y');
        } while ($done);
    }

    if ($output == 2){
        $msg = Msg::new("$prod->{nicconf}->{udevconffile} does not found");
        $msg->error();
        return 2;
    }
    do {
        $output = $prod->cli_ask_start_value();
        if (!$output) {
            Msg::log("Errors in sub cli_ask_start_value with return value: $output");
            return 0;
        }

        $output = $prod->init_internal_val();

        $output = $prod->phase_detect_nic_ip();
        if ($output == 1) {
        }
        if ($output ==2) {
            Msg::log("Errors in sub phase_detect_nic_ip with return value: $output");
            return 0;
        }
        if ($output ==3) {
            next;
        }

        $output = $prod->display_info();
        next if (!$output);

        $output = $prod->buildup_config_info();

        $output = $prod->phase_config_nic_ip_hostname();
        if (!$output) {
            Msg::log("Errors in sub phase_config_nic_ip_hostname with return value: $output");
            return 0;
        }

        $output = $prod->phase_config_nic_ip_hostname_post();
        if (!$output) {
            return 0;
        }

        $output = $prod->write_nasinstallconf();

        $output = $prod->handler_restart_network();

        if (!$output) {
            $prod->reboot_messages();
            $cpic=Obj::cpic();
            $cpic->edr_completion();
        }
        $flag = 0;
    } while ($flag);

    return 1;
}

sub init_cfg_val {
    my $prod = shift;
    my ($cfg,$clustername,$sys,$cpic,$console_ip);
    my (@private_devs,@public_devs,@vips,$netmask_list,$dev_list,$vip,$nvip,$netmask);
    my (@epws,@pris,@users,$epw,$user,$vcs_prod);
    $cpic = Obj::cpic();
    $sys = @{$cpic->{systems}}[0];
    $cfg = Obj::cfg();
    $vcs_prod = $prod->prod('VCS61');

    return 1 if (Cfg::opt('responsefile'));
    $clustername = $sys->cmd("_cmd_hostname 2>/dev/null");
    $clustername=~s/_(\d+)$//g;
    $cfg->{snas_clustername} = $clustername;

    # add users
    $vcs_prod->set_vcsencrypt();
    $user = 'admin';
    $epw = $vcs_prod->encrypt_password('password');
    push(@users,$user);
    push(@epws,$epw);
    push(@pris,'Administrators');
    $cfg->{vcs_username} = \@users;
    $cfg->{vcs_userpriv} = \@pris;
    $cfg->{vcs_userenpw} = \@epws;

    #FIXME: return for now.
    return 1;
    $console_ip = $sys->cmd("_cmd_cat $prod->{nicconf}->{consoleipfile} 2>/dev/null");
    chomp($console_ip);
    $console_ip = EDRu::despace($console_ip);
    $cfg->{snas_console_ip} = $console_ip;
    
    $dev_list = $sys->cmd("_cmd_cat $prod->{nicconf}->{publicdevicefile} 2>/dev/null"); 
    @public_devs = split(/\s+/, $dev_list);
    $cfg->{snas_public_nics} = \@public_devs;

    $dev_list = $sys->cmd("_cmd_cat $prod->{nicconf}->{privatedevicefile} 2>/dev/null");
    @private_devs = split(/\s+/, $dev_list);
    $cfg->{snas_private_nics} = \@private_devs;

    $netmask_list = $sys->cmd("_cmd_cat $prod->{nicconf}->{vipfile} 2>/dev/null");
    for my $line(split(/\n/, $netmask_list)) {
        ($vip, $netmask) = split(/\s+/, $line);
        push (@vips, $vip) if ($vip);
        $cfg->{snas_vip_netmask} ||= $netmask;
    };
    $cfg->{snas_vips} = \@vips;

    $nvip = $sys->cmd("_cmd_grep '^NVIPS' $prod->{nicconf}->{nasinstallconf} 2>/dev/null");
    if ( $nvip =~ /^NVIPS.*=\D*(\d+)/) {
        $cfg->{snas_nvips_per_nic} = $1;
    }

    return 1;
}

sub init_internal_val {
    my $prod = shift;
    my $cpic = Obj::cpic();
    for my $sys (@{$cpic->{systems}}) { 
        undef($sys->{oldhostname});
        undef($sys->{newhostname});
        undef(@{$sys->{publicnics}});
        undef(@{$sys->{privenics}});
        undef(@{$sys->{unpingnics}});
        undef($sys->{npublicnics});
        undef($sys->{nprivenics});
        undef(@{$sys->{publicnics_new}});
        undef(@{$sys->{privenics_new}});
        undef(@{$sys->{publicip}});
        undef(@{$sys->{publicnetmask}});
        undef(@{$sys->{privateip}});
        undef(@{$sys->{privatenetmask}});
    }
    return 1;
}

sub phase_detect_nic_ip {
    my $prod = shift;
    my ($cfg,$edr,$mode,$phase,$phase_name, $phase_desc,$task_name,%task_params,$id,$task);

    $cfg = Obj::cfg();
    $edr=Obj::edr();
    $mode = Cfg::opt('serial');
    Cfg::set_opt('serial', 1) if ($mode eq '');

    $phase_name="Detecting PCI Devices, Network Devices and Available IPs";
    $phase_desc=Msg::new("Detecting Network Devices and Available IPs");
    $edr->{$prod->{fatal_error_key}} = 0;
    $edr->{$prod->{ip_error_key}} = 0;

    $phase= Phase->new($phase_name);
    $phase->set_description($phase_desc);
    $phase->set_fatal_error_key($prod->{fatal_error_key});
    $phase->initialize_tasks();

    $id=100;
    $task_name="product_checking_pci_exclusion_nics";
    %task_params=(
            'sequence_id' => $id,
            'description' => Msg::new("Detecting PCI Devices"),
            'description_sys' => Msg::new("Detecting PCI Devices on #{SYS}"),
            'if_per_system' => 1,
            'handler' => \&handler_pciexclusion_sys,
            'handler_object_arg' => $prod,
            );
    $task=Task->new($task_name, %task_params);
    $phase->add_task($task);

    $id+=100;
    $task_name="product_checking_nics";
    %task_params=(
            'sequence_id' => $id,
            'description' => Msg::new("Detecting Network Devices"),
            'description_sys' => Msg::new("Detecting Network Devices on #{SYS}"),
            'if_per_system' => 1,
            'handler' => \&handler_check_nics_sys,
            'handler_object_arg' => $prod,
            'post_handler' => \&post_handler_check_nics,
            'post_handler_object_arg' => $prod,
            );
    $task=Task->new($task_name, %task_params);
    $phase->add_task($task);

    $id+=100;
    $task_name="product_detect_ip";
    %task_params=(
            'sequence_id' => $id,
            'description' => Msg::new("Detecting Available IPs"),
            'description_sys' => Msg::new("Detecting Available IP on #{SYS}"),
            'if_per_system' => 0,
            'handler' => \&handler_check_ip,
            'handler_object_arg' => $prod,
            );
    $task=Task->new($task_name, %task_params);
    $phase->add_task($task);

    $phase->execute_tasks();

    Cfg::unset_opt('serial') if ($mode eq '');

    return $prod->phase_detect_nic_ip_post();
}

sub phase_detect_nic_ip_post {
    my $prod = shift;
    my ($msg,$cfg,$edr,$cpic,$backopt,$ayn,$help,@errorsysarr,$errorsys);
    $cfg = Obj::cfg();
    $edr=Obj::edr();
    $cpic = Obj::cpic();
    @errorsysarr=();
    $edr->{$prod->{fatal_error_key}} = 0;
    for my $sys (@{$cpic->{systems}}) {
        if ($sys->{$prod->{fatal_error_key}}) { 
            $edr->{$prod->{fatal_error_key}} = 1;
            push (@errorsysarr,$sys->{sys});
        }
    }

    Msg::n();
    $msg=Msg::new("Detecting PCI Devices, Network Devices and Available IPs completed successfully.");
    $msg->bold;

    if ($edr->{$prod->{fatal_error_key}}) {
        $errorsys = join(' ',@errorsysarr);
        Msg::n();
        $msg=Msg::new("Not enough network devices exist on $errorsys.");
        $msg->error();
        return 2;
    }

    if ($edr->{$prod->{ip_error_key}} == 2) {
        Msg::n();
        $msg = Msg::new("No enough available public IP starting with initial IP address. Do you want to continue?");
        $ayn = $msg->ayny;
        if ($ayn eq 'N') {
            return 2;
        }
        return 3;
    }

    if ($edr->{$prod->{ip_error_key}} == 3) {
        Msg::n();
        $msg = Msg::new("No enough available virtual IP starting with initial IP address. Do you want to continue?");
        $ayn = $msg->ayny;
        if ($ayn eq 'N') {
            return 2;
        }
        return 3;
    }

    return 1;
}

sub phase_config_nic_ip_hostname {
    my $prod = shift;
    my ($phase,$phase_name, $phase_desc,$task_name,%task_params,$id,$task);
    my $cfg = Obj::cfg();
#Cfg::set_opt('serial', 1);
    $phase_name="Redefining NIC, IP, hostname, DNS, gateway";
    $phase_desc=Msg::new("Redefining NIC, IP, hostname, DNS, gateway");

    $phase= Phase->new($phase_name);
    $phase->set_description($phase_desc);
    $phase->initialize_tasks();

    $id=100;
    $task_name="product_renaming_nics";
    %task_params=(
            'sequence_id' => $id,
            'description' => Msg::new("Configuring NICs"),
            'description_sys' => Msg::new("Configuring NICs on #{SYS}"),
            'if_per_system' => 1,
            'handler' => \&handler_config_nicnames_sys,
            'handler_object_arg' => $prod,
            );
    $task=Task->new($task_name, %task_params);
    $phase->add_task($task);

    $id+=100;
    $task_name="product_reassigning_ip";
    %task_params=(
            'sequence_id' => $id,
            'description' => Msg::new("Configuring IP"),
            'description_sys' => Msg::new("Configuring IP on #{SYS}"),
            'if_per_system' => 0,
            'handler' => \&handler_config_ip,
            'handler_object_arg' => $prod,
            );
    $task=Task->new($task_name, %task_params);
    $phase->add_task($task);

    $id+=100;
    $task_name="product_redefining_hostname";
    %task_params=(
            'sequence_id' => $id,
            'description' => Msg::new("Configuring Hostname"),
            'description_sys' => Msg::new("Configuring Hostname on #{SYS}"),
            'if_per_system' => 1,
            'handler' => \&handler_config_hostname_sys,
            'handler_object_arg' => $prod,
            );
    $task=Task->new($task_name, %task_params);
    $phase->add_task($task);

    $id+=100;
    $task_name="product_redefining_dns";
    %task_params=(
            'sequence_id' => $id,
            'description' => Msg::new("Configuring DNS"),
            'description_sys' => Msg::new("Configuring DNS on #{SYS}"),
            'if_per_system' => 1,
            'handler' => \&handler_config_dns_sys,
            'handler_object_arg' => $prod,
            );
    $task=Task->new($task_name, %task_params);
    $phase->add_task($task);

    $id+=100;
    $task_name="product_redefining_gateway";
    %task_params=(
            'sequence_id' => $id,
            'description' => Msg::new("Configuring Gateway"),
            'description_sys' => Msg::new("Configuring Gateway on #{SYS}"),
            'if_per_system' => 1,
            'handler' => \&handler_config_gateway_sys,
            'handler_object_arg' => $prod,
            );
    $task=Task->new($task_name, %task_params);
    $phase->add_task($task);

#skip user group configuration
#   $id+=100;
#   $task_name="product_config_usergroup";
#   %task_params=(
#           'sequence_id' => $id,
#           'description' => Msg::new("Configuring User and Group"),
#           'description_sys' => Msg::new("Configuring User and Group on #{SYS}"),
#           'if_per_system' => 1,
#           'handler' => \&handler_users_groups_sys,
#           'handler_object_arg' => $prod,
#           );
#   $task=Task->new($task_name, %task_params);
#   $phase->add_task($task);

    $id+=100;
    $task_name="product_post_config_nicnames";
    %task_params=(
            'sequence_id' => $id,
            'description' => Msg::new("Performing postremove tasks"),
            'description_sys' => Msg::new("Performing postremove tasks on #{SYS}"),
            'if_per_system' => 1,
            'handler' => \&handler_postconfig_nicnames_sys,
            'handler_object_arg' => $prod,
            );
    $task=Task->new($task_name, %task_params);
    $phase->add_task($task);

    $phase->execute_tasks();

    return 1;
}

sub phase_config_nic_ip_hostname_post {
    my ($prod) = @_;
    my ($msg,$cfg);
    Msg::n();
    $msg=Msg::new("Redefining NIC, IP, hostname, DNS, gateway completed successfully.");
    $msg->bold;

    $cfg = Obj::cfg();
    $cfg->{opt}{confignic}=1;
    return 1;
}

sub handler_check_nics_sys {
    my ($prod,$sys) = @_;
    my ($cfg,$padv,$edr,$oldhostname,$ethall,$nerreths,$nconneths,$ndisconneths,$nexclusioneths,@conneths,@disconneths,@unpingeths,@erreths,@exclusioneths,$output,$pipstart,$gateway,$pnmaskstart,$ipproto,$src_ipv4,$src_ipv6,$src_mask,$src_prefix,@src_ipv4_arr,@src_ipv6_arr,@src_mask_arr,@src_prefix_arr,$scripts,$bits,$pipprefix,$ipaddress,$cmd,@src_prefixaddr,%src_ipv6_hash,$background);
    $cfg = Obj::cfg();
    $padv=$sys->padv;
    $edr=Obj::edr();

    $ethall=$padv->get_all_nic_sys($sys);

#here use gateway from client
#$gateway = $padv->get_gateway_sys($sys);
    $gateway = $cfg->{snas_defgateway};
    $pipstart = $cfg->{snas_pipstart};
    $pipprefix = $cfg->{snas_pipprefix};
    $pnmaskstart = $cfg->{snas_pnmaskstart};
    $bits = EDRu::mask2cidr($pnmaskstart) if($prod->{netproto} eq $prod->{netprotoipv4});
    $oldhostname = $sys->cmd("_cmd_hostname 2>/dev/null");
    $sys->set_value('oldhostname',$oldhostname);

    if ($prod->{netproto} eq $prod->{netprotoipv6}) {
        $ipaddress = "$pipstart\/$pipprefix";
        $ipproto = "-6";
    } else {
        $ipaddress = "$pipstart\/$bits";
        $ipproto = "-4";
    }

    $nerreths=0;
    $nconneths=0;
    $ndisconneths=0;
    $nexclusioneths=0;
    %src_ipv6_hash={};
    @conneths=();
    @disconneths=();
    @unpingeths=();
    @erreths=();
    @src_ipv4_arr = ();
    @src_ipv6_arr = ();
    @src_mask_arr = ();
    @src_prefix_arr = ();
    @src_ipv6_arr = ();
    @exclusioneths = ();

$scripts = <<"_NIC_CONFIG"; 
/sbin/chkconfig --level 123456 NetworkManager off >/dev/null 2>&1;
/sbin/service NetworkManager stop >/dev/null 2>&1;
/sbin/service network restart >/dev/null 2>&1;
/sbin/sysctl -w net.ipv4.conf.all.rp_filter=0 >/dev/null 2>&1;
/sbin/sysctl -w net.ipv4.conf.default.rp_filter=0 >/dev/null 2>&1;
_NIC_CONFIG

    $background = 1;
    $output = $sys->cmd_script($scripts,'','',$background);

    sleep 15;

    for my $eth (@{$ethall}) {
        $src_ipv4 = $sys->cmd("_cmd_ifconfig | _cmd_grep $eth -A 3| _cmd_grep 'inet addr' | _cmd_awk '{print \$2}'|_cmd_awk -F: '{print \$2}'");
        $src_mask = $sys->cmd("_cmd_ifconfig | _cmd_grep $eth -A 2 | _cmd_grep 'Mask' | _cmd_awk '{print \$4}'| _cmd_awk -F: '{print \$2}'");
        $src_ipv6 = $sys->cmd("_cmd_ifconfig | _cmd_grep $eth -A 3| _cmd_grep 'inet6 addr' | _cmd_awk '{print \$3}'|_cmd_awk -F'/' '{print \$1}'");

        my @src_ipv6addr = split(/\n/,$src_ipv6);
        $src_ipv6_hash{$eth}=\@src_ipv6addr;

        $src_prefix = $sys->cmd("_cmd_ifconfig | _cmd_grep $eth -A 3| _cmd_grep 'inet6 addr' | _cmd_awk '{print \$3}'|_cmd_awk -F'/'  '{print \$2}'");
        @src_prefixaddr = split(/\n/,$src_prefix);
        $output = $sys->cmd("/sbin/sysctl -w net.ipv4.conf.$eth.rp_filter=0");

        if ($src_ipv4 eq '' || $src_mask eq '') {
            $src_ipv4 = "0.0.0.0";
            $src_mask = "0.0.0.0";
        }

        if ($src_ipv6addr[0] eq '' || $src_prefixaddr[0] eq '') {
            $src_ipv6 = "0:0:0:0:0:0:0:0";
            $src_prefix = 64;
        } else {
            $src_ipv6 = $src_ipv6addr[0];
            $src_prefix = $src_prefixaddr[0];
        }

        push (@src_ipv4_arr,$src_ipv4);
        push (@src_ipv6_arr,$src_ipv6);
        push (@src_mask_arr,$src_mask);
        push (@src_prefix_arr,$src_prefix);

        if ($src_ipv4 eq $sys->{sys} || $src_ipv4 eq $sys->{ip} || EDRu::inarr($sys->{sys},@src_ipv6addr) || EDRu::inarr($sys->{ip},@src_ipv6addr) || $prod->find_exclusion_nic_sys($sys,$eth)) {
            next;
        } else {
            $output = $sys->cmd("_cmd_ip addr flush $eth >/dev/null 2>&1; _cmd_ifconfig $eth down >/dev/null 2>&1");
        }
    }

    my $id = 0; 
    for my $eth (@{$ethall}){
        if ($prod->find_exclusion_nic_sys($sys,$eth)) {
            $id++;
            push (@exclusioneths, $eth); 
            $nexclusioneths++;
            next;
        }

        if (@src_ipv4_arr[$id] eq $sys->{sys} || @src_ipv6_arr[$id] eq $sys->{sys} ||$ndisconneths >= $prod->{max_priv_nic_num} || @src_ipv4_arr[$id] eq $sys->{ip} || EDRu::inarr($sys->{ip},@{$src_ipv6_hash{$eth}}) || EDRu::inarr($sys->{sys},@{$src_ipv6_hash{$eth}})) {
            $id++;
            $nconneths++;
            push (@conneths, $eth);
            next;
        }

        $id++;

$scripts = <<"_NIC_CONFIG";
/sbin/ip link set $eth up >/dev/null 2>&1;
/sbin/ip addr flush $eth  >/dev/null 2>&1;
/sbin/ip $ipproto addr add $ipaddress dev $eth >/dev/null 2>&1;
_NIC_CONFIG

        $background = 1;
        $output = $sys->cmd_script($scripts,'','',$background);

        sleep 5;
        if(EDR::cmdexit()!=0) {
            $nerreths++;
            push (@erreths, $eth);
            Msg::log("set up $eth failed, set as error nics");
            next;
        }

        if ($prod->{netproto} eq $prod->{netprotoipv4}) {
            $output = $sys->cmd("_cmd_ping -i 2 -c 3 -I $eth $gateway 2>/dev/null");
        } else {
            $output = $sys->cmd("_cmd_ping6 -i 2 -c 3 -I $eth $gateway 2>/dev/null");
        }

        if (!EDR::cmdexit()) {
            $nconneths++;
            push (@conneths, $eth);
        } else {
            if ($ndisconneths < $prod->{max_priv_nic_num}) {
                $ndisconneths++;
                push (@disconneths, $eth);
            } else {
                $nconneths++;
                push (@conneths, $eth);
            }
            push (@unpingeths, $eth);
        }
        
        $output = $sys->cmd("_cmd_ip addr flush $eth >/dev/null 2>&1; _cmd_ifconfig $eth down >/dev/null 2>&1");
    }

    for my $eth (@{$ethall}) {
        $src_ipv4 = shift  @src_ipv4_arr;
        $src_ipv6 = shift  @src_ipv6_arr;
        $src_mask = shift @src_mask_arr;
        $src_prefix = shift @src_prefix_arr;

        if ($src_ipv4 eq $sys->{sys} || $src_ipv4 eq $sys->{ip} || EDRu::inarr($sys->{sys},@{$src_ipv6_hash{$eth}}) || EDRu::inarr($sys->{ip},@{$src_ipv6_hash{$eth}}) || $prod->find_exclusion_nic_sys($sys,$eth)) {
            next;
        } else {
            if ($src_ipv4 ne "0.0.0.0" || $src_ipv6 ne "0:0:0:0:0:0:0:0") {
                $cmd = '';

                if ($src_ipv4 ne "0.0.0.0") {
                    $bits = EDRu::mask2cidr($src_mask);
                    $ipaddress = "$src_ipv4\/$bits";
                    $ipproto = "-4";
                    $cmd .= "/sbin/ip $ipproto addr add $ipaddress dev $eth  >/dev/null 2>&1;\n";
                }
                if ($src_ipv6 ne "0:0:0:0:0:0:0:0") {
                    $ipaddress = "$src_ipv6\/$src_prefix";
                    $ipproto = "-6";
                    $cmd .= "/sbin/ip $ipproto addr add $ipaddress dev $eth  >/dev/null 2>&1;\n";
                }

$scripts = <<"_NIC_CONFIG"; 
/sbin/ip link set $eth up >/dev/null 2>&1;
/sbin/ip addr flush $eth >/dev/null 2>&1;
$cmd
_NIC_CONFIG

                $background = 1;
                $output = $sys->cmd_script($scripts,'','',$background);
                sleep 5;

            } else {
                $output = $sys->cmd("_cmd_ifconfig $eth up >/dev/null 2>&1");
                $output = $sys->cmd("_cmd_ip addr flush dev $eth >/dev/null 2>&1");
            }
        }
    }

#if ($prod->ismasternode()) {

#    }

    $sys->set_value('publicnics','push',@conneths);
    $sys->set_value('privenics','push',@disconneths);
    $sys->set_value('unpingnics','push',@unpingeths);
    $sys->set_value('exclusioneths','push',@exclusioneths);
    $sys->set_value('npublicnics',$nconneths);
    $sys->set_value('nprivenics',$ndisconneths);
    $sys->set_value('nexclusioneths',$nexclusioneths);

    if ($nconneths >= $prod->{minimum_pub_nic_num} && $ndisconneths >= $prod->{mininum_priv_nic_num}) {
        return 1;
    } else {
        $sys->set_value($prod->{fatal_error_key},1);
        return 0;
    }
}

sub handler_pciexclusion_sys {
    my ($prod, $sys) = @_;
    my ($cfg, $edr, $msg, @pciid, @exclusionnic, $counter, $output,@fieldarr,$index,$i);
    $cfg = Obj::cfg();
    $edr = Obj::edr();
    @exclusionnic = ();
    $counter = 0;

    if (!$cfg->{snas_pciexclusionid}) {
        $sys->set_value('pciexclusion','push',@exclusionnic);
        return 1;
    }

    @pciid = split(/\s+|[,;_]/,$cfg->{snas_pciexclusionid});

    for my $id (@pciid) {
        $output = $sys->cmd("_cmd_lshal | _cmd_grep 'linux.sysfs_path =.*/net/.*' | _cmd_grep -v 'virtual' |_cmd_awk -F \\' '{print \$2}'| _cmd_grep -iw $id"); 
        @fieldarr = split(/\//,$output);
        $index = @fieldarr;
        for ($i = $index -1; $i >= 0; $i--) {
            if(@fieldarr[$i] eq "net"){
                push (@exclusionnic, @fieldarr[$i+1]);
                $counter++;
                last;
            }
        }
    }

    $sys->set_value('pciexclusion','push',@exclusionnic);
    return 1;
}

sub find_exclusion_nic_sys {
    my ($prod,$sys,$nic) = @_;
    my ($match);
    my $cfg = Obj::cfg();
    $match = grep /^$nic/,@{$sys->{pciexclusion}};
    return 1 if ($match);
    return 0;
}

sub handler_config_gateway_sys {
    my ($prod, $sys) = @_;
    my ($cfg, $padv, $edr, $msg, $output);
    $cfg = Obj::cfg();
    $padv=$sys->padv;
    $output = $padv->configure_gateway_sys($sys,$cfg->{snas_defgateway});
    if ($output) {
    
    } else {
    
    }
    return 1;
}

sub handler_check_ip {
    my ($prod) = @_;
    my ($cfg, $edr, $output);
    my $cfg = Obj::cfg();
    my $edr = Obj::edr();
    return 1 if (Cfg::opt('responsefile') && !Cfg::opt('addnode'));
    if ($prod->{netproto} eq $prod->{netprotoipv4}) {
        $output = $prod->precheck_ip_range($cfg->{snas_pipstart},$cfg->{snas_vipstart},$cfg->{snas_pnmaskstart},$cfg->{snas_vnmaskstart});   
    } else {
        $output = $prod->precheck_ip_range($cfg->{snas_pipstart},$cfg->{snas_vipstart},$cfg->{snas_pipprefix},$cfg->{snas_vipprefix});   
    }
    if ($output == 2) {
        Msg::log("public ip is out of range, install failed!");
        $edr->{$prod->{ip_error_key}} = 2;
        return 0;
    }
    if ($output == 3) {
        Msg::log("virtual ip is out of range, install failed!");
        $edr->{$prod->{ip_error_key}} = 3;
        return 0;
    }

    return 1;
}

sub handler_config_nicnames_sys {
    my ($prod,$sys) = @_;
    my ($cfg,$cpic,$output);
    $cfg = Obj::cfg();
    $cpic = Obj::cpic();
    $output = $prod->configure_nicnames($sys);
    if (!$output) {
        return 0;
    }
    return 1;
}

sub handler_postconfig_nicnames_sys {
    my ($prod,$sys) = @_;
    my ($cfg,$cpic,$fname,$ifcfgdir,$ifcfgfile,$cmd,$scripts,$output);
    
    $ifcfgdir = "/etc/sysconfig/network-scripts/ifconfig_bak"; 
    $ifcfgfile = "/etc/sysconfig/network-scripts/ifcfg-";
    $cfg = Obj::cfg();
    $cpic = Obj::cpic();
    $sys->mkdir($ifcfgdir);
    $cmd = '';

    for my $eth (@{$sys->{publicnics}}) {
        next if (($eth =~ /^pubeth\d+$/m) || ($eth =~ /^priveth\d+$/m));
        $fname = $ifcfgfile.$eth."*";
        $cmd .= "/bin/mv $fname $ifcfgdir\n";
    }
    for my $eth (@{$sys->{privenics}}) {
        next if (($eth =~ /^pubeth\d+$/m) || ($eth =~ /^priveth\d+$/m));
        $fname = $ifcfgfile.$eth."*";
        $cmd .= "/bin/mv $fname $ifcfgdir\n";
    }

$scripts = <<"_POST_CONFIG"; 
$cmd
_POST_CONFIG

    $output = $sys->cmd_script($scripts);
    return 1;
}

sub handler_config_hostname_sys {
    my ($prod,$sys) = @_;
    my $output;
    $output = $prod->configure_hostnames($sys);
    if (!$output) {
        return 0;
    }
    return 1;
}

sub handler_config_ip {
    my ($prod) = @_;
    my ($output,$sysi,$sys0,$system,@syslist);

    my $cfg = Obj::cfg();
    $output = $prod->configure_ip_nics();
    if (!$output) {
#TBD
#return 0;
    }

    if (Cfg::opt('addnode')) {
        $sysi = @{$cfg->{clustersystems}}[0];
        $sys0 = Obj::sys($sysi);
        $prod->addnode_write_config_files_sys($sys0);

        for my $sys(@{$cfg->{clustersystems}}[1..$#{$cfg->{clustersystems}}]) {
            $system = Obj::sys($sys);
            push(@syslist, $system);
        }
        push(@syslist, @{CPIC::get('systems')});
        $prod->copy_conf_to_othernodes($sys0,\@syslist);
    } else {
        for my $sys(@{CPIC::get('systems')}) {
            $prod->write_config_files_sys($sys);
        }
    }
    return 1;
}

sub handler_config_dns_sys {
    my ($prod, $sys) = @_;
    my ($padv,$cfg,$cpic,$output,$padv);
    $cfg = Obj::cfg();
    $cpic = Obj::cpic();
    $padv=$sys->padv;
    $output = $padv->configure_dns_sys($sys,$cfg->{snas_dnsip},$cfg->{snas_dnsdomainname});
    if (!$output) {
        Msg::log("configure dns error");
#TBD
#return 0;
    }
    return 1;
}

sub handler_users_groups_sys {
    my ($prod,$sys) =@_;
    my ($output);
    $output = $prod->add_users_sys($sys);
    if ($output) {
        #TBD;
    }
    $output = $prod->add_groups_sys($sys);
    if ($output) {
        #TBD;
    }
    return 1;
}

sub post_handler_check_nics {
    my $prod = shift;
    my ($cpic,$edr,$cfg,$rtn,$msg);
    $cpic = Obj::cpic();
    $cfg = Obj::cfg();
    for my $sys (@{$cpic->{systems}}) {
        if ($sys->{$prod->{fatal_error_key}}) { 
            $edr->{$prod->{fatal_error_key}} = 1;
        }
    }
    # NIC number should be the same in all nodes in the cluster
    $rtn = $prod->nicnum_consistency_check();
    if ($rtn) {
        $msg = Msg::new("Please make sure the cluster nodes have the same public and private NIC");
        $msg->error();
    }

    return 0 if($edr->{$prod->{fatal_error_key}});
    return 1;
}

sub preconfig_precheck{
    my $prod = shift;
    my ($cpic, $sys,$msg,$flag);
    $cpic = Obj::cpic();
    $flag=0;
    for $sys (@{$cpic->{systems}}) {
        return 2 if (!$sys->exists($prod->{nicconf}->{udevconffile}));
        if ($prod->precheck_nicname($sys)) {
            $flag=1;
            last;
        }
    }

    if ($flag) {
        Msg::log("NIC is already renamed, skipping nic and host rename");
        return 0;
    }

    return 1;
}

sub precheck_nicname {
    my ($prod, $sys) = @_;
    my ($padv, $edr, $ethall);
    $padv=$sys->padv;
    $edr=Obj::edr();

    $ethall=$padv->get_all_nic_sys($sys);
    for my $eth (@{$ethall}) {
       if (($eth =~ /^pubeth\d+$/m) || ($eth =~ /^priveth\d+$/m)) {
           return 1;
       }
    }
    return 0;
}

sub cli_ask_start_value {
    my $prod = shift;
    my ($ayn,$padv,$cfg,$done,$msg,$msg_str,$help,$backopt,$netm,$mcnic_ref,$prefix,$vcs,$vip,$snas,$pipstart,$pnmaskstart,$vipstart,$vnmaskstart,$clustername,$def_gateway,$dnsip,$dnsdomainname,$pciexclusionid,$consoleip,$output,$hintpnmask,$hintvnmask,$rpn,$defnic,$nicl,$output,$nvips,$sepconsoleport,$pipprefix);
    $cfg = Obj::cfg();
    $backopt = '';

    my $cpic = Obj::cpic();
    my $sys = @{$cpic->{systems}}[0];
    $padv=$sys->padv;
    $rpn = $padv->publicnics_sys($sys);
    if ($#$rpn<0) {
        $msg = Msg::new("No active NIC devices have been discovered on $sys->{sys}");
        $msg->warning();
    } else {
        $nicl = join(' ',@$rpn);
    }
    $defnic = $$rpn[0];

    return 1 if (Cfg::opt('responsefile'));

    Msg::title();
    $msg = Msg::new("The following data is required to configure the Storage NAS cluster:\n");
    $msg->bold;
    $msg = Msg::new("\tThe Storage NAS cluster name");
    $msg->printn;
    $msg = Msg::new("\tA initial public IP address and netmask");
    $msg->printn;
    $msg = Msg::new("\tA initial virtual IP address and netmask");
    $msg->printn;
    $msg = Msg::new("\tDefault Gateway IP address");
    $msg->printn;
    $msg = Msg::new("\tDNS Server IP address and Domain name");
    $msg->printn;
    $msg = Msg::new("\tConsole Virtual IP address");
    $msg->printn;
    $msg = Msg::new("\tPCI IDs for PCI exclusion");
    $msg->printn;
    $msg = Msg::new("System IP addresses will be defined sequentially starting with the initial address. System hostnames will be renamed as clustername_01, clustername_02, etc.");
    $msg->printn;

    do {
        $clustername = $prod->ask_clustername();
        $clustername = EDRu::despace($clustername);
        next if (EDR::getmsgkey($clustername,'back'));


        $pipstart = $prod->ask_pip_sys($sys);
        $pipstart = EDRu::despace($pipstart);
        next if (EDR::getmsgkey($pipstart,'back'));

        if (EDRu::ip_is_ipv6($pipstart)) {
            $prod->{netproto} = $prod->{netprotoipv6};
        } else {
            $prod->{netproto} = $prod->{netprotoipv4};
        }

        if ($prod->{netproto} eq $prod->{netprotoipv4}) {
            $hintpnmask = $sys->defaultnetmask($pipstart,$defnic);
            $pnmaskstart = $prod->ask_pnmask_sys($sys,$hintpnmask);
            $pnmaskstart = EDRu::despace($pnmaskstart);
            next if (EDR::getmsgkey($pnmaskstart,'back'));
        } else {
            $hintpnmask = $sys->defaultnetmask($pipstart,$defnic);
            $pipprefix = $prod->ask_pipprefix($hintpnmask);
            $pipprefix = EDRu::despace($pipprefix);
            next if (EDR::getmsgkey($pnmaskstart,'back'));
        }

        $vipstart = $prod->ask_vip_sys($sys);
        $vipstart = EDRu::despace($vipstart);
        next if (EDR::getmsgkey($vipstart,'back'));

        $nvips = $prod->ask_nvip(1);
        $nvips = EDRu::despace($nvips);
        next if (EDR::getmsgkey($nvips,'back'));

        $def_gateway = $prod->ask_default_gateway_sys($sys);
        $def_gateway = EDRu::despace($def_gateway);
        next if (EDR::getmsgkey($def_gateway,'back'));

        $dnsip = $prod->ask_dnsip_sys($sys);
        $dnsip = EDRu::despace($dnsip);
        next if (EDR::getmsgkey($dnsip,'back'));

        $dnsdomainname = $prod->ask_dnsdomainname_sys($sys);
        $dnsdomainname = EDRu::despace($dnsdomainname);
        next if (EDR::getmsgkey($dnsdomainname,'back'));

        $consoleip = $prod->ask_consoleip();
        $consoleip = EDRu::despace($consoleip);
        next if (EDR::getmsgkey($consoleip,'back'));

        $sepconsoleport = $prod->ask_sep_console_port();
        $sepconsoleport = EDRu::despace($sepconsoleport);
        next if (EDR::getmsgkey($sepconsoleport,'back'));

        $output = $prod->ask_pciexclusionid_option(); 
        if ($output) {
            $pciexclusionid = $prod->ask_pciexclusionid();
            $pciexclusionid = EDRu::despace($pciexclusionid);
            next if (EDR::getmsgkey($pciexclusionid,'back'));
        }

        Msg::n();
        $msg = Msg::new("Is this information correct?");
        $ayn = $msg->ayny;
        $done = 1 if ($ayn eq 'Y');
    } while (!$done);

    $cfg->{snas_pipstart} = $pipstart;
    $cfg->{snas_pnmaskstart} = $pnmaskstart;
    $cfg->{snas_clustername} = $clustername;
    $cfg->{snas_vipstart} = $vipstart;
    $cfg->{snas_vnmaskstart} = $pnmaskstart;
    $cfg->{snas_defgateway} = $def_gateway;
    $cfg->{snas_dnsip} = $dnsip;
    $cfg->{snas_dnsdomainname} = $dnsdomainname;
    $cfg->{snas_consoleip} = $consoleip;
    $cfg->{snas_pciexclusionid} = $pciexclusionid;
    $cfg->{snas_nvip} = $nvips;
    $cfg->{snas_pipprefix} = $pipprefix;
    $cfg->{snas_sepconsoleport} = $sepconsoleport;
    $cfg->{snas_vipprefix} = $pipprefix;

    return 1;
}

sub display_info {
    my ($prod) = @_;
    my ($output) ;

    $output = $prod->display_initial_value();
    if ($output) {
        Msg::log("display ip pool info success!");
        return 1;
    } else {
        Msg::log("display ip pool info failed!");
        return 0;
    }

}

sub display_initial_value {
    my ($prod) = @_;
    my (@titles,$cfg,$cpic,@pip,@vip,@nmask,@vnmask,@pubeths,@priveths,$pubprefix,$index,$msg,$oldhostname,$newhostname,$hostnameid,$id,$nicid,$ayn,$done,$privprefix,$i,$pid,$vid);

    $cfg = Obj::cfg();
    $cpic = Obj::cpic();

    $index=0;
    $pubprefix = "pubeth";
    $privprefix = "priveth";
    if (Cfg::opt('responsefile') && !Cfg::opt('addnode')) {
        $prod->{snas_ip_pool}->{public} = $cfg->{publiciparr};
        $prod->{snas_ip_pool}->{private} = $cfg->{virtualiparr};
        $prod->{snas_nmask_pool}->{public} = $cfg->{publicnetmaskarr};
        $prod->{snas_nmask_pool}->{private} = $cfg->{virtualnetmaskarr};
        return 1;
    }

    @pip = @{$prod->{snas_ip_pool}->{public}};
    @vip = @{$prod->{snas_ip_pool}->{private}};
    @nmask = @{$prod->{snas_nmask_pool}->{public}};
    @vnmask = @{$prod->{snas_nmask_pool}->{private}};
    $cfg->{publiciparr} = \@pip;
    $cfg->{virtualiparr} = \@vip;
    $cfg->{publicnetmaskarr} =  \@nmask;
    $cfg->{virtualnetmaskarr} = \@vnmask;

    return 1 if (Cfg::opt('responsefile')); 

    Msg::title();
    $msg = Msg::new("Configuration Checklist:");
    $msg->bold;

    Msg::n();

    $hostnameid = 1;
    $index = 0;
    $nicid =0;
    for my $sys (@{$cpic->{systems}}) {


        printf "%-20s%-20s\n","System:",$sys->{sys};

        $oldhostname = $sys->{oldhostname};

        if ($hostnameid < 10) {
            $newhostname = $cfg->{snas_clustername}."_0".$hostnameid;
        } else {
            $newhostname = $cfg->{snas_clustername}."_".$hostnameid;
        }
        printf "\t%-20s%-20s\n","Hostname",$oldhostname;
        printf "\t%-20s%-20s\n","new Hostname",$newhostname;
        $hostnameid++;

        printf "\t%-20s%-20s\n","Gateway IP:",$cfg->{snas_defgateway};
        printf "\t%-20s%-20s\n","DNS IP:",$cfg->{snas_dnsip};
        printf "\t%-20s%-20s\n","Domain Name:",$cfg->{snas_dnsdomainname};
        Msg::n();

        $pid=0;
        $vid=0;
        @pubeths =  @{$sys->{publicnics}};
        for my $eth (@pubeths) {
            printf "\t%-20s%-20s\n","NIC name:",$eth;
            printf "\t%-20s%-20s\n","new NIC name:",$pubprefix.$pid;
            printf "\t%-20s%-20s\n","Physical IP:",@pip[$index++];
            printf "\t%-20s","Virtual IP:";

            for ($i = 0 ; $i < $cfg->{snas_nvip};) {
                if ($i != 0) {

                    printf "\n\t%-20s"," ";
                }
                printf "%-20s",@vip[(($nicid * $cfg->{snas_nvip}) + ($i++))];
            }
            $nicid++;
            $pid++;
            Msg::n();
            Msg::n();
        }

        @priveths = @{$sys->{privenics}};
        for my $eth (@priveths) {
            printf "\t%-20s%-20s\n","NIC name:",$eth;
            printf "\t%-20s%-20s\n","new NIC name:",$privprefix.$vid;
            Msg::n();
            $vid++;
        }
    }

    Msg::n();
    $msg = Msg::new("Is this information correct?");
    $ayn = $msg->ayny;
    return 1 if ($ayn eq 'Y');

    return 0;
}

sub precheck_ip_range {
    my ($prod,$pipstart,$vipstart,$pnmaskstart,$vnmaskstart) = @_;
    my ($cfg,$sys,$padv,$npublicnicall,$nprivatenicall,$output,$id,$inuse,$vipbit,$vipstartbit,$pipbit,$pipstartbit,@nip);
    my $cfg = Obj::cfg();
    my $cpic = Obj::cpic();
    $npublicnicall = 0;
    for $sys (@{$cpic->{systems}}) {
        $npublicnicall  +=  $sys->{npublicnics};
    }

    my $pip = $pipstart;
    my $vip = $vipstart;
    $sys = @{$cpic->{systems}}[0];
    $padv  = $sys->padv;
    $id = 0;
    $prod->truncate_ip_pool();
    do {
        $output = $prod->check_ip_available($sys,$pip); 
        if (!$output) {
            Msg::log("$pip is invalid!");
            $pip = $prod->get_next_ip($pip,1);
        }
        else {
            $prod->set_ip_to_ppool($pip);
            $prod->set_nmask_to_ppool($pnmaskstart);
            $pip = $prod->get_next_ip($pip,1);
            $id++;
        }

        if ($prod->{netproto} eq $prod->{netprotoipv4}) {
            @nip = split(/\./,$pip);
            if ($nip[3] >= 255) {
                Msg::log("$pip is invalid! Out of range!");
                return 2;
            }
        } else {
            $pipbit = EDRu::ipv6bit($pip,$pnmaskstart);
            $pipstartbit = EDRu::ipv6bit($pipstart,$pnmaskstart);
            if ($pipbit != $pipstartbit || $pipbit ==2 || $pipstartbit==2) {
                Msg::log("$pip is invalid! Out of range!");
                return 2;
            }
        }
    } while ($id < $npublicnicall);

    $id = 0;
    do {
        $output = $prod->check_ip_available($sys,$vip); 
        if (!$output) {
            Msg::log("$vip is invalid!");
            $vip = $prod->get_next_ip($vip,1);
        }
        else {
            $inuse = $prod->dedup_vip($vip);
            if (!$inuse) {
                $prod->set_ip_to_vpool($vip);
                $prod->set_nmask_to_vpool($vnmaskstart);
                $vip = $prod->get_next_ip($vip,1);
                $id++;
            } else {
                Msg::log("$vip is inuse!");
                $vip = $prod->get_next_ip($vip,1);
            }
        }

        if ($prod->{netproto} eq $prod->{netprotoipv4}) {
            @nip = split(/\./,$vip);
            if ($nip[3] >= 255) {
                Msg::log("$vip is invalid! Out of range!");
                return 3;
            }
        } else {
            $vipbit = EDRu::ipv6bit($vip,$vnmaskstart);
            $vipstartbit = EDRu::ipv6bit($vipstart,$vnmaskstart);
            if ($vipbit != $vipstartbit || $vipbit ==2 || $vipstartbit==2) {
                Msg::log("$vip is invalid! Out of range!");
                return 3;
            }
        }
    } while ($id < $npublicnicall*$cfg->{snas_nvip});

    return 1;
}

sub get_hint_ip {
    my ($prod,$sys,$ip) = @_;
    my ($i,$hint,$output,$flag);
    my $padv=$sys->padv;
    $hint = $ip;
    $flag = 0;
    for ($i = 0; $i < 6; $i++) { 
        $hint = $prod->get_next_ip($hint,1);
        $output = $prod->check_ip_available($sys,$hint);
        if (!$output) { 
            $flag = 1;
            next;
        } else {
            $flag = 0;
            last;
        }
    }
    if ($flag == 0) {
        return $hint;
    } else {
        return "0.0.0.0";
    }
}

sub check_pciid_available {
    my ($prod, $pciidstr) = @_;
    my (@pciid,$output);
    @pciid = split(/\s+|[,;_]/,$pciidstr);
    for my $id (@pciid) {
       $output = $id =~ /^[\da-z]+:[\da-z]+:[\da-z]+\.[\da-z]+$/;
       return 0 if (!$output);
    }
    return 1;
}

sub check_ip_available {
    my ($prod,$sys,$ip) = @_;
    my ($ipversion,$ipversion1,$ipversion2,$id,$padv,$ret1,$ret2);
    my $localsys=EDR::get('localsys');
    $id = 0;
    $padv=$sys->padv;
    $ipversion1 = EDRu::ip_is_ipv4($ip);
    $ipversion2 = EDRu::ip_is_ipv6($ip);

    if (!$ipversion1 && !$ipversion2) {
        return 0;
    }
    if ($ipversion1 == 1) {
        $ipversion = 4;
    } else {
        $ipversion = 6;
    }
    my $ret1 = EDRu::ip_iptype($ip,$ipversion);
    my $ret2 = $localsys->padv->ping($ip);
    if ($ret1 eq 'PUBLIC' && $ret2 eq 'noping') {
        return 1;
    }
    return 0;
}

sub dedup_vip {
    my ($prod, $vip) = @_;
    my ($cfg, $matchpip,$matchvip);
    $cfg= Obj::cfg();
    $matchpip = grep /^$vip/,@{$prod->{snas_ip_pool}->{public}};
    $matchvip = grep /^$vip/,@{$prod->{snas_ip_pool}->{private}};
    if ($matchpip || $matchvip) {
        return 1;
    }
    return 0;
}

sub buildup_config_info {
    my ($prod) = @_;
    my ($hostnameid,$cpic,$oldhostname,$cfg,$pubprefix,$privprefix,@conneths,$nconneths,@disconneths,$nconneths_new,$ndisconneths_new,$nconneths,$ndisconneths,$pubid,$privid,$pip,$pmask,$vip,$vmask,$i);

    $cfg= Obj::cfg();
    $cpic = Obj::cpic();

    if (Cfg::opt('addnode')) {
        $prod->addnode_init_new_hostname();
    } else {
        $hostnameid = 1;

        for my $sys (@{$cpic->{systems}}) {
            $oldhostname = $sys->{oldhostname};
            if ($hostnameid < 10) {
                $sys->{newhostname} = $cfg->{snas_clustername}."_0".$hostnameid;
            } else {
                $sys->{newhostname} = $cfg->{snas_clustername}."_".$hostnameid;
            }
            $hostnameid++;
        }
    }

    $pubprefix = $prod->{pubnic_prefix};
    $privprefix = $prod->{privnic_prefix};
    $nconneths_new = 0;
    $ndisconneths_new = 0;

    for my $sys (@{$cpic->{systems}}) {
        my @conneths_new = ();
        my @disconneths_new = ();
        $nconneths = $sys->{npublicnics};
        $ndisconneths = $sys->{nprivenics};
        if ( $nconneths == 0) {
            @conneths = (); 
        }
        else {
            @conneths =  @{$sys->{publicnics}};
        }

        if ( $ndisconneths == 0) {
            @disconneths = (); 
        }
        else {
            @disconneths = @{$sys->{privenics}}; 
        }

        $pubid = 0;
        for my $eth (@conneths) {
            push (@conneths_new,$pubprefix.$pubid);
            $pubid++;
        }

        $privid = 0;
        for my $eth (@disconneths) {
            push (@disconneths_new,$privprefix.$privid);
            $privid++;
        }

        $sys->set_value('publicnics_new','push', @conneths_new);
        $sys->set_value('npublicnics_new', $pubid);
        $sys->set_value('privenics_new','push', @disconneths_new);
        $sys->set_value('nprivenics_new', $privid);
    }

    for my $sys (@{$cpic->{systems}}) {
        my @pubip_arr=();
        my @pubnmask_arr=();
        my @privip_arr=();
        my @privnmask_arr=();

        for my $eth (@{$sys->{publicnics_new}}) {
            $pip = $prod->get_ip_from_ppool();
            $pmask = $prod->get_nmask_from_ppool();
            push (@pubip_arr,$pip);
            push (@pubnmask_arr,$pmask);

            for ($i = 0 ; $i < $cfg->{snas_nvip}; $i++) {
                $vip = $prod->get_ip_from_vpool();
                $vmask = $prod->get_nmask_from_vpool();
                push (@privip_arr,$vip);
                push (@privnmask_arr,$vmask);
            }
        }

        $sys->set_value('publicip','push', @pubip_arr);
        $sys->set_value('publicnetmask','push', @pubnmask_arr);
        $sys->set_value('privateip','push', @privip_arr);
        $sys->set_value('privatenetmask','push', @privnmask_arr);
    }
    return 1;
}

sub configure_nicnames {
    my ($prod,$sys) = @_;
    my ($padv,$pubprefix,$priprefix,$gateway,$nconneths,$ndisconneths,@conneths,@disconneths,$nconneths_new,$ndisconneths_new,@conneths_new,@disconneths_new,$output,$id,$output,$couldrestart,$index);

    $padv=$sys->padv;
    my $cfg = Obj::cfg();
#$gateway = $padv->get_gateway_sys($sys); #may be sth err!
    $gateway = $cfg->{snas_defgateway};
    $couldrestart = 1;

    @conneths = @{$sys->{publicnics}};
    @disconneths = @{$sys->{privenics}};
    @conneths_new = @{$sys->{publicnics_new}};
    @disconneths_new = @{$sys->{privenics_new}};

    for ($index = 0; $index < @conneths; $index++) {
        $output = $padv->configure_nicname_sys($sys,@conneths[$index],@conneths_new[$index]);
        $couldrestart &= $output;
    }

    for ($index = 0; $index < @disconneths; $index++) {
        $output = $padv->configure_nicname_sys($sys,@disconneths[$index],@disconneths_new[$index]);
        $couldrestart &= $output;
    }

    return 1 if ($couldrestart);
    return 0;
}

sub configure_hostnames {
    my ($prod,$sys) = @_;
    my ($output,$padv);
    $padv=$sys->padv;
    $output = $padv->configure_hostname_sys($sys,$sys->{newhostname});
    if (!$output) {
        Msg::log("$sys config hostname failed!");
        return 0;
    } else {
        return 1;
    }
}

sub configure_ip_nics {
    my ($prod) = @_;
    my ($cfg);
    my (@pubeths,@priveths,@pubethsnew,@privethsnew,$pip,$pmask,$vip,$vmask,$output,$res,$index,$nic,$nicnew,$i);
    my (@iphostsarr,@freepriviparr,@physicaliparr,@privatedevicearr,@privateiparr,@publicdevicearr,@pubip_arr,@viparr,@vip_arr,@vipdevicearr);
    my ($newsysname,$padv,$sys,$syslist);
    $cfg = Obj::cfg();

    $syslist = CPIC::get('systems');
    $sys = ${$syslist}[0];
    $padv=$sys->padv;
    @privethsnew =  @{$sys->{privenics_new}};
    @pubethsnew =  @{$sys->{publicnics_new}};

#$pmask = ${$sys->{publicnetmask}}[0];
#$vmask = ${$sys->{privatenetmask}}[0];

    if ($prod->{netproto} eq $prod->{netprotoipv4}) {
        $pmask = $cfg->{snas_pnmaskstart};
        $vmask = $pmask;
       } else {
        $pmask = $cfg->{snas_pipprefix};
        $vmask = $pmask;
    }

    @physicaliparr = ();
    @publicdevicearr = ();
    @privatedevicearr = ();
    @privateiparr = ();
    @viparr = ();
    @vipdevicearr = ();
    $res = 1;
    $index = 0;
    @freepriviparr = @{$prod->{priviparr}};

    for my $system (@$syslist) {
        $newsysname = $system->{newhostname};
        @pubip_arr = @{$system->{publicip}};
        @vip_arr = @{$system->{privateip}};
        $system->set_value('hostip',$pubip_arr[0]);
        @pubeths =  @{$system->{publicnics}};
        @priveths =  @{$system->{privenics}};
        for ($index = 0; $index < @pubip_arr; $index++) {
            $pip = $pubip_arr[$index];
            $nic = $pubeths[$index];
            $nicnew = $pubethsnew[$index];
            # rename NIC and configure public physical IP on each system
            $output = $padv->configure_ip_sys($system,$nic,$nicnew,$pip,$pmask,$prod->{netproto});
            $res &= $output;
            push (@physicaliparr, "$pip $pmask $newsysname $nicnew");

            for ($i = $index*$cfg->{snas_nvip} ; $i < ($index+1)*$cfg->{snas_nvip}; $i++) {
                $vip = $vip_arr[$i];
                push (@viparr, "$vip $vmask");
            }
        }
# rename NIC and configure private IP on priveth0 of each system
        my $privip = shift @freepriviparr;
        $output = $padv->configure_ip_sys($system,$priveths[0],$privethsnew[0],$privip,$prod->{privateipnetmask},$prod->{netprotoipv4});
        $res &= $output;
        push (@privateiparr, "$privip $prod->{privateipnetmask} $newsysname $privethsnew[0]");
        push (@iphostsarr, "$privip\t$newsysname");
    }
    # generate private ip array of all the systems 
    unless (Cfg::opt('addnode')) {
        for my $privip (@freepriviparr) {
            push (@privateiparr, "$privip $prod->{privateipnetmask}");
        }
    }

    @publicdevicearr = @pubethsnew;
    @vipdevicearr = @pubethsnew;
    @privatedevicearr = @privethsnew;

    $prod->set_value('physicaliparr','push', @physicaliparr);
    $prod->set_value('publicdevicearr','push', @publicdevicearr);
    $prod->set_value('privatedevicearr','push', @privatedevicearr);
    $prod->set_value('privateiparr','push', @privateiparr);
    $prod->set_value('viparr','push', @viparr);
    $prod->set_value('vipdevicearr','push', @vipdevicearr);
    $prod->set_value('iphostsarr','push', @iphostsarr);

    return $res;
}

sub write_config_files_sys {
    my ($prod,$sys) = @_;
    my $cfg = Obj::cfg();
    my @physicaliparr =@{$prod->{physicaliparr}};
    my @publicdevicearr = @{$prod->{publicdevicearr}};
    my @privatedevicearr = @{$prod->{privatedevicearr}};
    my @privateiparr = @{$prod->{privateiparr}};
    my @viparr = @{$prod->{viparr}};
    my @vipdevicearr = @{$prod->{vipdevicearr}};
    my @iphostsarr = @{$prod->{iphostsarr}};

    $sys->mkdir($prod->{nicconf}->{filepath});
    $prod->set_physicalipfile_sys($sys,@physicaliparr);
    $prod->set_publicdevicefile_sys($sys,@publicdevicearr);
    $prod->set_privatedevicefile_sys($sys,@privatedevicearr);
    $prod->set_privateipfile_sys($sys,@privateiparr);
    $prod->set_vipfile_sys($sys,@viparr);
    $prod->set_vipdevicefile_sys($sys,@vipdevicearr);
    $prod->set_consoleipfile_sys($sys);
    $prod->set_consoledevfile_sys($sys);
    $prod->set_globalroutesfile_sys($sys);
    $prod->update_hosts_file_sys($sys,@iphostsarr);

#$prod->write_nasinstallconf_sys($sys);
    return 1;
}

sub handler_restart_network{
    my ($prod) = @_;
    my ($syslist, $cmd, @pubeths,@pubethsnew,@priveths,@privethsnew,@pubip_arr,$pip,$pubnic,$privnic,$pubnicnew,$privnicnew,$scripts,$output,$index,$msg,$ret,$cfg,$pipprefix,$pnmaskstart,$bits,$ipaddress,$ipproto,%nichash,$background,@newnodes);
    $cfg=Obj::cfg();
    $syslist = CPIC::get('systems');
    %nichash = {};

    $pipprefix = $cfg->{snas_pipprefix};
    $pnmaskstart = $cfg->{snas_pnmaskstart};
    $bits = EDRu::mask2cidr($pnmaskstart) if($prod->{netproto} eq $prod->{netprotoipv4});

    if ($prod->{netproto} eq $prod->{netprotoipv6}) {
        $ipproto = "-6";
    } else {
        $ipproto = "-4";
    }  

    $cmd = '';

    for my $system (@$syslist) {
        @pubeths =  @{$system->{publicnics}};
        @pubethsnew =  @{$system->{publicnics_new}};
        @priveths =  @{$system->{privenics}};
        @privethsnew =  @{$system->{privenics_new}};
        @pubip_arr = @{$system->{publicip}};

        $cmd="";
        for ($index = 0; $index < @pubeths; $index++) {
            $pubnic = $pubeths[$index];
            $cmd .= "/sbin/ip link set $pubnic down >/dev/null 2>&1;\n";
            $cmd .= "/sbin/ip link set $pubnic name pubn$index >/dev/null 2>&1;\n";
            $nichash{$pubnic}="pubn$index";
        }

        for ($index = 0; $index < @priveths; $index++) {
            $privnic = $priveths[$index];
            $cmd .= "/sbin/ip link set $privnic down >/dev/null 2>&1;\n";
            $cmd .= "/sbin/ip link set $privnic name privn$index >/dev/null 2>&1;\n";
            $nichash{$privnic}="privn$index";
        }

        for ($index = 0; $index < @pubeths; $index++) {
            $pip = $pubip_arr[$index];
            $pubnic = $pubeths[$index];
            $pubnicnew = $pubethsnew[$index];

            if ($prod->{netproto} eq $prod->{netprotoipv6}) {
                $ipaddress = "$pip\/$pipprefix";
            } else {
                $ipaddress = "$pip\/$bits";
            } 

            $cmd .= "/sbin/ip link set $nichash{$pubnic} name $pubnicnew >/dev/null 2>&1;\n";
            $cmd .= "/sbin/ip link set $pubnicnew up >/dev/null 2>&1;\n";
            $cmd .= "/sbin/ip addr flush $pubnicnew >/dev/null 2>&1;\n";
            $cmd .= "/sbin/ip $ipproto addr add $ipaddress dev $pubnicnew >/dev/null 2>&1;\n";
        }

        for ($index = 0; $index < @priveths; $index++) {
            $privnic = $priveths[$index];
            $privnicnew = $privethsnew[$index];

            $cmd .= "/sbin/ip link set $nichash{$privnic} name $privnicnew >/dev/null 2>&1;\n";
            $cmd .= "/sbin/ip link set $privnicnew up >/dev/null 2>&1;\n";
        }

        $cmd .= "/sbin/service network restart >/dev/null 2>&1;\n";

$scripts = <<"_RESTART_NETWORK"; 
$cmd
_RESTART_NETWORK

        Msg::log("restarting $system->{sys}");
        $background = 1;
        $system->cmd_script($scripts,'','',$background);
        Msg::log("finish restarting $system->{sys}");
        $Obj::pool{"Sys::$pubip_arr[0]"} = $Obj::pool{"Sys::$system->{sys}"};
        my $sys = $Obj::pool{"Sys::$pubip_arr[0]"};
        $sys->{sys} = $pubip_arr[0];
        $sys->{ip} = $pubip_arr[0];
        $sys->{pool} = "Sys::$pubip_arr[0]";
        $sys->{hostname} = $sys->{newhostname};
        $sys->{vcs_sysname} = $sys->{hostname};
        push(@newnodes, $sys->{sys});
    }

    $cfg->{newnodes} = \@newnodes;
    sleep 15;
    my $localsys=EDR::get('localsys');
    for my $system (@$syslist) {
        $ret = $localsys->padv->ping($system->{sys});
        if ($ret eq 'noping') {
            Msg::log("$system->{sys} start failed");
            $msg = Msg::new("$system->{sys} auto re-start failed");
            $msg->error;
            return 0;
        } else {
            Msg::log("$system->{sys} start success");
            return 1;
        }
    }
    return 0;
}

sub reboot_messages {
    my ($prod) = @_;
    my ($reboot_msg,$msg,$cpic,$padv,@reboot_systems,@reboot_systems_ip,$reboot_systems_str,$reboot_systems_ip_str);

    $cpic=Obj::cpic();
    $padv=Obj::padv($cpic->{padv});
    @reboot_systems=();
    @reboot_systems_ip=();
    for my $sys (@{$cpic->{systems}}) {
        push (@reboot_systems,$sys->{sys}); 
        push (@reboot_systems_ip,@{$sys->{publicip}}[0]);
    }
    $reboot_systems_str = join(' ',@reboot_systems);
    $reboot_systems_ip_str = join(' ',@reboot_systems_ip);
    $msg=Msg::new("It is strongly recommended to reboot the following systems:\n\t$reboot_systems_str\n\nExecute '$padv->{cmd}{shutdown}' to properly restart your systems");
    $reboot_msg.=$msg->{msg};
    my $script=EDR::get('script');
    $msg=Msg::new("\n\nAfter reboot, run the '$script -configure' to continue configuring the following systems:\n\t$reboot_systems_ip_str");
    $reboot_msg.=$msg->{msg};
    Msg::display_bold($reboot_msg);
    return 1;
}

sub add_groups_sys {
    my ($prod, $sys)=@_;
    $sys->cmd("_cmd_groupadd -g 1001 master");
    $sys->cmd("_cmd_groupadd -g 1002 sysadmin");
    $sys->cmd("_cmd_groupadd -g 1003 stoadmin");
    $sys->cmd("_cmd_groupadd -g 1004 sysstoadmin");
    $sys->cmd("_cmd_groupadd -g 1005 Xmaster");
    return 1;
}

sub add_users_sys {
    my ($prod,$sys)=@_;
    $sys->mkdir($prod->{clish}->{clishhomepath});
    $sys->mkdir($prod->{clish}->{supporthomepath});
    $sys->cmd("_cmd_userdel -r master");
    $sys->cmd("_cmd_useradd master -d $prod->{clish}->{clishhomepath} -s $prod->{clish}->{clishpath} -g Xmaster -G master,root,sysadmin,stoadmin,sysstoadmin");
    $sys->cmd("_cmd_usermod -o -u 0 master");
    $sys->cmd("_cmd_chown -R master:Xmaster $prod->{clish}->{clishhomepath}");
    $sys->cmd("_cmd_useradd support -d $prod->{clish}->{supporthomepath} -s $prod->{clish}->{bashpath} -g root");
    $sys->cmd("_cmd_usermod -o -u 0 support");
    return 1;
}

sub build_key_path {
    my ($prod) = @_;
    my (%kvs,$cfg,$cpic);

    %kvs = {};
    $cfg = Obj::cfg();
    $cpic = Obj::cpic();

    $kvs{"MODE"} = $prod->{mode}->{master};
    $kvs{"LICENSE_TYPE"}="ENTERPRISE";
    $kvs{"LICENSE"}="8RZG-3FSI-RVFF-8OTJ-ZLGO-WZP8-O63P-P";
    $kvs{"GATEWAYNAME"}=$cfg->{snas_clustername};
    $kvs{"NNODES"}=@{$cpic->{systems}};
    $kvs{"SINGLENODE"}="no";
    $kvs{"SEPCONSOLE"}=$cfg->{snas_sepconsoleport};
    $kvs{"NVIPS"}=$cfg->{snas_nvip};
    $kvs{"PCIEXCLUSIONID"}=$cfg->{snas_pciexclusionid};
    $kvs{"PIPSTART"}=$cfg->{snas_pipstart};
    $kvs{"PIPMASK"}=$cfg->{snas_pnmaskstart};
    $kvs{"VIPMASK"}=$cfg->{snas_vnmaskstart};
    $kvs{"VIPSTART"}=$cfg->{snas_vipstart};
    $kvs{"CONSIP"}=$cfg->{snas_consoleip};
    $kvs{"NTPSERVER"}="ntp.symantec.com";
    $kvs{"DNS"}=$cfg->{snas_dnsip};
    $kvs{"DOMAINNAME"}=$cfg->{snas_dnsdomainname};
    $kvs{"GATEWAY"}=$cfg->{snas_defgateway};
    $kvs{"NPORTS"}="4";
    $kvs{"PUBBONDEVICEID"}='';
    $kvs{"PUB_BOND_MODE"}="1";
    $kvs{"NLMMASTERIP"}="172.16.0.2";
    $kvs{"DHCP_RANGE_START"}="172.16.0.20";
    $kvs{"DHCP_RANGE_END"}="172.16.0.35";
    $kvs{"PRIVATE_NET_SUBNET"}="172.16.0.0";
    $kvs{"PRIVATE_NET_NETMASK"}="255.255.255.0";
    $kvs{"NETPROTO"}=$prod->{netproto};

    return \%kvs;
}

sub build_nasinstallconf_sys {
    my ($prod,$sys) = @_;
    my ($padv,@items,$confhash,$macs,$mac);

    $padv=$sys->padv;
    $confhash = $prod->build_key_path();
    $macs = $prod->get_all_nics_mac_sys($sys);
    $mac = join(',',@{$macs});
    if ($sys->system1 && !Cfg::opt('addnode')) {
        $confhash->{"MODE"}=$prod->{mode}->{master};
        $confhash->{"INSTSERVVIP"}="172.16.0.1";
        $confhash->{"NPORTS"}=@{$prod->{publicdevicearr}}+@{$prod->{privatedevicearr}};
    } else {
        $confhash->{"MODE"}=$prod->{mode}->{slave};
        $confhash->{"NPORTS"}=@{$prod->{publicdevicearr}}+@{$prod->{privatedevicearr}};
        $confhash->{"SERVERIP"}="172.16.0.1";
        $confhash->{"MACS"}=$mac;
        $confhash->{"PRIVATE0_MAC"}= $padv->get_mac_by_nic_sys($sys,@{$sys->{privenics}}[0]);
    }

    foreach my $key(sort (keys %{$confhash})) {
        next unless ($confhash->{$key}); 
        push (@items,$key);
        push (@items,"\"$confhash->{$key}\"");
    }

    $sys->set_value('nasinstallconf','push', @items);
    return 1;
}

sub write_nasinstallconf {
    my ($prod) = @_;
    my ($output,$cpic);
    $cpic = Obj::cpic();
    for my $sys (@{$cpic->{systems}}) {
        $output = $prod->write_nasinstallconf_sys($sys);
    }
}

sub write_nasinstallconf_sys{
    my ($prod,$sys) = @_;
    my ($file,$filelocpath,$obj,$edr,$cpic,$tmpdir);
    
    $edr=Obj::edr();
    $tmpdir=EDR::tmpdir();

    $filelocpath = "$tmpdir/nasinstall.conf"; 
    $file = $prod->{nicconf}->{nasinstallconf};

    $sys->mkdir("$prod->{nicconf}->{nodefilepath}");
    $sys->cmd("_cmd_touch $prod->{nicconf}->{nasinstallconf}");
    $sys->cmd("_cmd_cat /dev/null > $prod->{nicconf}->{nasinstallconf}");

    $prod->build_nasinstallconf_sys($sys);

    $prod->set_default_values($filelocpath,@{$sys->{nasinstallconf}});
    if ($sys->{islocal}) {
        $sys->copyfile($filelocpath,$file);
    } else {
        $edr->localsys->copy_to_sys($sys,$filelocpath,$file);
    }
    return 1;
}

sub get_all_nics_mac_sys {
    my ($prod,$sys) = @_;
    my ($padv,$output,@macs,$cpic);

    $cpic=Obj::cpic();
    $padv=$sys->padv;
    @macs=();

    my @publicdevicearr = @{$sys->{publicnics}};
    my @privatedevicearr = @{$sys->{privenics}};
    for my $nic (@publicdevicearr) {
        $output = $padv->get_mac_by_nic_sys($sys,$nic);
        push (@macs, $output);
    }
    for my $nic (@privatedevicearr) {
        $output = $padv->get_mac_by_nic_sys($sys,$nic);
        push (@macs, $output); 
    }
    return \@macs;
}

sub set_physicalipfile_sys {
    my ($prod,$sys,@arr) = @_;
    my $content;
    for my $line (@arr) {
        $content .= "$line\n";
    }
    if (Cfg::opt('addnode')) {
        chomp($content);
        $sys->appendfile($content,$prod->{nicconf}->{physicalipfile});
    } else {
        $sys->writefile($content,$prod->{nicconf}->{physicalipfile});
    }
    return 1;
}

sub set_publicdevicefile_sys {
    my ($prod,$sys,@arr) = @_;
    my $line = join(' ',@arr);
    $line .= "\n";
    $sys->writefile($line,$prod->{nicconf}->{publicdevicefile});
    return 1;
}

sub set_vipdevicefile_sys  {
    my ($prod,$sys,@arr) = @_;
    my $line = join(' ',@arr);
    $line .= "\n";
    $sys->writefile($line,$prod->{nicconf}->{vipdevicefile});
    return 1;
}

sub set_privatedevicefile_sys  {
    my ($prod,$sys,@arr) = @_;
    my $line = $arr[0];
    $line .= "\n";
    $sys->writefile($line,$prod->{nicconf}->{privatedevicefile});
    return 1;
}

sub set_privateipfile_sys  {
    my ($prod,$sys,@arr) = @_;
    my ($content,$ip);
    if (Cfg::opt('addnode')) {
        for my $line (@arr) {
            ($ip, undef) = split(/\s+/, $line);
            $sys->cmd("_cmd_sed -i 's/^$ip.*\$/$line/' $prod->{nicconf}->{privateipfile} 2>/dev/null");
        }
    } else {
        for my $line (@arr) {
            $content .= "$line\n";
        }
        $sys->writefile($content,$prod->{nicconf}->{privateipfile});
    }
    return 1;
}

sub set_vipfile_sys  {
    my ($prod,$sys,@arr) = @_;
    my $content;

    for my $line (@arr) {
        $content .= "$line\n";
    }
    if (Cfg::opt('addnode')) {
        chomp($content);
        $sys->appendfile($content,$prod->{nicconf}->{vipfile});
    } else {
        $sys->writefile($content,$prod->{nicconf}->{vipfile});
    }

    return 1;
}

sub set_consoleipfile_sys  {
    my ($prod,$sys) = @_;
    my ($cfg, $content);
    $cfg = Obj::cfg();

    $content = "$cfg->{snas_consoleip} ${$sys->{privatenetmask}}[0]\n";
    $sys->writefile($content,$prod->{nicconf}->{consoleipfile});

    return 1;
}

sub set_consoledevfile_sys  {
    my ($prod,$sys) = @_;
    my $content = "${$prod->{publicdevicearr}}[0]\n";
    $sys->writefile($content,$prod->{nicconf}->{consoledevfile});
    return 1;
}

sub set_globalroutesfile_sys {
    my ($prod,$sys) = @_;
    my ($content,$syslist,$id,$hostname,$cfg);
    $cfg= Obj::cfg();
    $syslist = CPIC::get('systems');
    $content = '';
    $id = 1;
    for my $system (@$syslist) {
        $hostname = $system->{newhostname};

        if ($prod->{netproto} eq $prod->{netprotoipv4}) {
            $content .= "$hostname 0.0.0.0/0 $cfg->{snas_defgateway} - -\n";
        } else {
            $content .= "$hostname ::/0 $cfg->{snas_defgateway} - -\n";
        }
        $id++;
    }
    if (Cfg::opt('addnode')) {
        chomp($content);
        $sys->appendfile($content,$prod->{nicconf}->{globalroutes});
    } else {
        $sys->writefile($content,$prod->{nicconf}->{globalroutes});
    }
}


sub update_hosts_file_sys {
    my ($prod,$sys,@vars) = (@_);
    my ($hostsfile,$content,$ip,$host);
    $hostsfile = $prod->{hostsfile};
    for my $line(@vars) {
        ($ip,$host) = split (/\s+/, $line);
        # TBD: better to read to temp and execute only 1 system command
        $sys->cmd("_cmd_sed -i '/$host/d' $hostsfile 2>/dev/null");
        $sys->appendfile($line,$hostsfile);
    }
    return 1;
}

sub get_next_ip {
    my ($prod,$ip,$step) = @_;
    my (@nip,$iparr);
    if (!(EDRu::ip_is_ipv4($ip)) && !(EDRu::ip_is_ipv6($ip))) {
        return "0.0.0.0";    
    }
    if (EDRu::ip_is_ipv4($ip)) {
        @nip = split(/\./,$ip);
        $nip[3]+=$step;
        if ($nip[3]>255) {
            $nip[2] += ($nip[3] - 255);
            $nip[3] -= 255;
        }
        if ($nip[2]>255) {
            $nip[1] += ($nip[2] - 255);
            $nip[2] -= 255;
        }
        if ($nip[1]>255) {
            $nip[0] += ($nip[1] - 255);
            $nip[1] -= 255;
        }
        if ($nip[0]>255) {
            return "0.0.0.0";
        }
        $ip = $nip[0].".".$nip[1].".".$nip[2].".".$nip[3];
    } else {
        $iparr = EDRu::ipv6toarr($ip);
        @nip = @{$iparr};
        $nip[7]=EDRu::hex2dec($nip[7]);
        $nip[6]=EDRu::hex2dec($nip[6]);
        $nip[5]=EDRu::hex2dec($nip[5]);
        $nip[4]=EDRu::hex2dec($nip[4]);
        $nip[3]=EDRu::hex2dec($nip[3]);
        $nip[2]=EDRu::hex2dec($nip[2]);
        $nip[1]=EDRu::hex2dec($nip[1]);
        $nip[0]=EDRu::hex2dec($nip[0]);

        $nip[7]+=$step;

        if ($nip[7] > 65535) {
            $nip[6] += ($nip[7] - 65535);
            $nip[7] -= 65535;
        }

        if ($nip[6] > 65535) {
            $nip[5] += ($nip[6] - 65535);
            $nip[6] -= 65535;
        }
        if ($nip[5] > 65535) {
            $nip[4] += ($nip[5] - 65535);
            $nip[5] -= 65535;
        }

        if ($nip[4] > 65535) {
            $nip[3] += ($nip[4] - 65535);
            $nip[4] -= 65535;
        }
        if ($nip[3] > 65535) {
            $nip[2] += ($nip[3] - 65535);
            $nip[3] -= 65535;
        }
        if ($nip[2] > 65535) {
            $nip[1] += ($nip[2] - 65535);
            $nip[2] -= 65535;
        }
        if ($nip[1] > 65535) {
            $nip[0] += ($nip[1] - 65535);
            $nip[1] -= 65535;
        }
        if ($nip[0] > 65535) {
            return "0:0:0:0:0:0:0:0";
        }

        $nip[7] = EDRu::dec2hex($nip[7]);
        $nip[6] = EDRu::dec2hex($nip[6]);
        $nip[5] = EDRu::dec2hex($nip[5]);
        $nip[4] = EDRu::dec2hex($nip[4]);
        $nip[3] = EDRu::dec2hex($nip[3]);
        $nip[2] = EDRu::dec2hex($nip[2]);
        $nip[1] = EDRu::dec2hex($nip[1]);
        $nip[0] = EDRu::dec2hex($nip[0]);

        $ip = "$nip[0]:$nip[1]:$nip[2]:$nip[3]:$nip[4]:$nip[5]:$nip[6]:$nip[7]";
    }
    return $ip;
}

sub get_next_mask {
    my ($prod,$ip,$step) = @_;
    return $ip;
}

sub truncate_ip_pool {
    my ($prod) = @_;
    my $cfg= Obj::cfg();
    @{$prod->{snas_ip_pool}->{public}} = ();
    @{$prod->{snas_ip_pool}->{private}} = ();
    @{$prod->{snas_nmask_pool}->{public}} = ();
    @{$prod->{snas_nmask_pool}->{private}} = ();
    return 1;
}

sub set_ip_to_ppool {
    my ($prod,$ip) = @_;
    push (@{$prod->{snas_ip_pool}->{public}},$ip);
    return;
}

sub get_ip_from_ppool{
    my ($prod) = @_;
    my $ip = shift @{$prod->{snas_ip_pool}->{public}};
    return $ip;
}

sub set_ip_to_vpool {
    my ($prod,$ip) = @_;
    push (@{$prod->{snas_ip_pool}->{private}},$ip);
    return;
}

sub get_ip_from_vpool{
    my ($prod) = @_;
    my $ip = shift @{$prod->{snas_ip_pool}->{private}};
    return $ip;
}

sub set_nmask_to_ppool {
    my ($prod,$ip) = @_;
    push (@{$prod->{snas_nmask_pool}->{public}},$ip);
    return;
}

sub get_nmask_from_ppool {
    my ($prod) = @_;
    my $ip = shift @{$prod->{snas_nmask_pool}->{public}};
    return $ip;
}

sub set_nmask_to_vpool {
    my ($prod,$ip) = @_;
    push (@{$prod->{snas_nmask_pool}->{private}},$ip);
    return;
}

sub get_nmask_from_vpool{
    my ($prod) = @_;
    my $ip = shift @{$prod->{snas_nmask_pool}->{private}};
    return $ip;
}

sub ask_pip_sys {
    my ($prod,$sys)=@_;
    my ($answer,$backopt,$done,$msg,$help);

    $done=0;
    $backopt='';
    while (!$done) {
        $help=Msg::new("The public IP address is used for detecting the public and private NICs, and system IP addresses will be defined sequentially starting with the initial address.\nEnter the first or starting physical IP address from the range of physical IP addresses that your network administrator provided. These IP addresses must be in a consecutive numerical range.");
        $msg=Msg::new("Enter the public IP starting address:");

        $answer=$msg->ask('',$help,$backopt);

        if (!EDRu::isip($answer) || !$prod->check_ip_available($sys,$answer)) {
            $msg=Msg::new("$answer contains invalid IP address");
            $msg->print;
            next; 
        }
        $done=1;
    }
    return $answer;
}

sub ask_pnmask_sys {
    my ($prod,$sys,$hint)=@_;
    my ($answer,$backopt,$done,$msg,$help);

    $done=0;
    $backopt='';
    while (!$done) {
        $help=Msg::new("The netmask is common for physical and virtual IP addresses.");
        $msg=Msg::new("Enter the netmask for the public IP address:");

        $answer=$msg->ask($hint,$help,$backopt);

        if (!EDRu::isip($answer)) {
            $msg=Msg::new("$answer contains invalid IP address");
            $msg->print;
            next; 
        }
        $done=1;
    }
    return $answer;
}

sub ask_vip_sys {
    my ($prod,$sys)=@_;
    my ($answer,$backopt,$done,$msg,$help,$hintvip);

    $done=0;

    while (!$done) {
        $help=Msg::new("Enter the first or starting virtual IP address from the range of virtual IP addresses that your network administrator provided. These IP addresses must be in a consecutive numerical range.");
        $msg=Msg::new("Enter the virtual IP starting address:");
        $hintvip='';

        $answer=$msg->ask($hintvip,$help,$backopt);

        return $answer if (EDR::getmsgkey($answer,'back'));
        if ((!EDRu::ip_is_ipv4($answer) && ($prod->{netproto} eq $prod->{netprotoipv4})) || (!EDRu::ip_is_ipv6($answer) && ($prod->{netproto} eq $prod->{netprotoipv6})) || !EDRu::isip($answer) || !$prod->check_ip_available($sys,$answer)) {
            $msg=Msg::new("$answer contains invalid IP address");
            $msg->print;
            next; 
        }
        $done=1;
    }

    if (EDRu::ip_is_ipv4($answer)) {
        $prod->{netprotovip} = $prod->{netprotoipv4}; 
    } else {
        $prod->{netprotovip} = $prod->{netprotoipv6}; 
    }
    return $answer;
}

sub ask_vnmask_sys {
    my ($prod,$sys,$hintvnmask)=@_;
    my ($answer,$backopt,$done,$msg,$help);

    $done=0;
    $backopt='';
    while (!$done) {
        $help=Msg::new("The netmask is common for physical and virtual IP addresses.");
        $msg=Msg::new("Enter the netmask for the virtual IP address:");
        if ($hintvnmask eq "0.0.0.0" ) {
            $hintvnmask = '';
        }
        $answer=$msg->ask($hintvnmask,$help,$backopt);
        if (!EDRu::isip($answer)) {
            $msg=Msg::new("$answer contains invalid IP address");
            $msg->print;
            next; 
        }
        $done=1;
    }
    return $answer;
}

sub ask_clustername {
    my ($prod)=@_;
    my ($vcs,$answer,$backopt,$done,$msg,$help);
    $vcs=$prod->prod('VCS61');

    $done=0;
    $backopt='';
    while (!$done) {
        $help=Msg::new("The cluster name is used in the configuration files and all the nodes will be renamed as clustername_01, clustername_02 and so on in Storage NAS cluster.");
        $msg=Msg::new("Enter the Storage NAS Cluster name:");
        $answer=$msg->ask('',$help,$backopt);
        return $answer if (EDR::getmsgkey($answer,'back'));
        next if (!$vcs->verify_clustername($answer));
        $done=1;
    }
    return $answer;
}

sub ask_default_gateway_sys {
    my ($prod,$sys,$netproto)=@_;
    my ($answer,$backopt,$done,$msg,$help,$locgateway,$padv);

    $padv=$sys->padv;
    $locgateway = $padv->get_gateway_sys($sys,$prod->{netproto});
    $locgateway = '' if ($prod->{netproto} eq $prod->{netprotoipv6} && !EDRu::ip_is_ipv6($locgateway));
    $done=0;
    $backopt='';
    while (!$done) {
        $help=Msg::new("The IP address for the default gateway.");
        $msg=Msg::new("Enter the default gateway IP address:");
        $answer=$msg->ask($locgateway,$help,$backopt);
        if ((!EDRu::ip_is_ipv4($answer) && ($prod->{netproto} eq $prod->{netprotoipv4})) || (!EDRu::ip_is_ipv6($answer) && ($prod->{netproto} eq $prod->{netprotoipv6}))) {
            $msg=Msg::new("$answer contains invalid IP address");
            $msg->print;
            next; 
        }          
        $done=1;
    }    
    return $answer;
} 

sub ask_dnsip_sys {
    my ($prod,$sys)=@_;
    my ($padv,$answer,$backopt,$done,$msg,$help,$localdns);

    $padv=$sys->padv;
    $localdns = $padv->get_dns_sys($sys);

    $localdns = '' if (($prod->{netproto} eq $prod->{netprotoipv6} && !EDRu::ip_is_ipv6($localdns)) || ($prod->{netproto} eq $prod->{netprotoipv4} && !EDRu::ip_is_ipv4($localdns)));
    $done=0;
    $backopt='';
    while (!$done) {
        $help=Msg::new("The IP address for the Domain Name System (DNS) server.");
        $msg=Msg::new("Enter the DNS IP address:");
        $answer=$msg->ask($localdns,$help,$backopt);

        if ((!EDRu::ip_is_ipv4($answer) && ($prod->{netproto} eq $prod->{netprotoipv4})) || (!EDRu::ip_is_ipv6($answer) && ($prod->{netproto} eq $prod->{netprotoipv6}))) {
            $msg=Msg::new("$answer contains invalid IP address");
            $msg->print;
            next; 
        }        
        $done=1;
    }    
    return $answer;
} 

sub ask_dnsdomainname_sys {
    my ($prod,$sys)=@_;
    my ($padv,$answer,$backopt,$done,$msg,$help,$localdomain);

    $padv=$sys->padv;
    $localdomain = $padv->get_domain_sys($sys);

    $done=0;
    $backopt='';
    while (!$done) {
        $help=Msg::new("The DNS domain name is used for set it as the default for all the nodes in Storage NAS Cluster.");
        $msg=Msg::new("Enter the DNS domain Name:");
        $answer=$msg->ask($localdomain,$help,$backopt);
        return $answer if (EDR::getmsgkey($answer,'back'));
        if ($answer  eq '') {
            $msg=Msg::new("$answer is null");
            $msg->print;
            next; 
        }          
        $done=1;
    }    
    return $answer;
} 

sub ask_consoleip {
    my ($prod)=@_;
    my ($answer,$backopt,$done,$msg,$help);

    $done=0;
    $backopt='';
    while (!$done) {
        $help=Msg::new("The virtual IP address for the cluster management console.");
        $msg=Msg::new("Enter the console virtual IP address:");
        $answer=$msg->ask('',$help,$backopt);
        if ((!EDRu::ip_is_ipv4($answer) && ($prod->{netproto} eq $prod->{netprotoipv4})) || (!EDRu::ip_is_ipv6($answer) && ($prod->{netproto} eq $prod->{netprotoipv6}))) {
            $msg=Msg::new("$answer contains invalid IP address");
            $msg->print;
            next; 
        }        
        $done=1;
    }    
    return $answer;
}

sub ask_pciexclusionid_option {
    my ($prod)=@_;
    my ($answer,$backopt,$ayn,$msg,$help);
    Msg::n();
    $msg = Msg::new("Do you want to exclude NICs by PCI IDs?");
    $ayn = $msg->aynn;
    if ($ayn eq 'N') {
        return 0;
    }
    return 1;
}

sub ask_pciexclusionid {
    my ($prod)=@_;
    my ($answer,$backopt,$done,$msg,$help);

    $done=0;
    $backopt='';
    while (!$done) {
        $help=Msg::new("The PCI ID for PCI exclusion is used for skipping the detection and configuration on the NIC which is specified with PCI ID for exclusion.");
        $msg=Msg::new("Enter the PCI IDs for PCI exclusion:");
        $answer=$msg->ask('',$help,$backopt);
        if (!$prod->check_pciid_available($answer)) {
            $msg=Msg::new("$answer contains invalid PCI ID");
            $msg->print;
            next;
        }
        $done=1;
    }    
    return $answer;
} 

sub ask_pipprefix{
    my ($prod,$hint)=@_;
    my ($answer,$backopt,$done,$msg,$help);

    $done=0;
    $backopt='';
    while (!$done) {
        $help=Msg::new("The netmask is common for physical and virtual IP addresses.");
        $msg=Msg::new("Enter the prefix for public IP address:");

        $answer=$msg->ask($hint,$help,$backopt);

        if (!EDRu::isint($answer) || $answer > 128 || $answer < 1) {
            $msg=Msg::new("$answer contains invalid IPV6 Prefixlength");
            $msg->print;
            next; 
        }
        $done=1;
    }
    return $answer;
}

sub ask_nvip {
    my ($prod,$hint)=@_;
    my ($answer,$backopt,$done,$msg,$help);

    $done=0;
    $backopt='';
    while (!$done) {
        $help=Msg::new("The netmask is common for physical and virtual IP addresses.");
        $msg=Msg::new("Enter the number of VIPs per interface:");

        $answer=$msg->ask($hint,$help,$backopt);

        if (!EDRu::isint($answer) || $answer <= 0 || $answer >= 10) {
            $msg=Msg::new("$answer contains invalid number of VIPs per interface");
            $msg->print;
            next; 
        }
        $done=1;
    }
    return $answer;
}

sub ask_sep_console_port {
    my ($prod)=@_;
    my ($answer,$backopt,$done,$msg,$help,$hint);

    $done=0;
    $backopt='';
    $hint="0";
    while (!$done) {
        $msg=Msg::new("Do you want to use the seperate console port?");
        $answer=$msg->aynn;

        if ($answer eq 'N') {
            $answer = '0';
        }
        if ($answer eq 'Y'){
            $answer = '1';
        }
        $done=1;
    }
    return $answer;
}

sub poststart_sys {
    my ($prod,$sys) = @_;
    my ($vcs,$sysname,$syslist,$msg);

    $vcs = $prod->prod('VCS61');
    $prod->SUPER::poststart_sys($sys);
    return unless (Cfg::opt('configure'));
    if ($sys->system1) {
        $msg = Msg::new("Starting service groups");
        $msg->left();
        $sys->cmd("$prod->{installerdir}/installer -m master 2>/dev/null");
        $msg->right_done();
        $syslist = CPIC::get('systems');
        $prod->copy_conf_to_othernodes($sys,$syslist);
        EDRu::create_flag('snas_configure_done');
    } else {
        EDRu::wait_for_flag('snas_configure_done');
        $msg = Msg::new("Node $sys->{newhostname}( $sys->{sys} ) joining cluster");
        $msg->left();
        $sys->cmd("$prod->{installerdir}/installer -m join 2>/dev/null");
        $msg->right_done();
    }
    return;
}

sub copy_conf_to_othernodes {
    my ($prod,$sys,$syslist) = @_;
    my ($filepath,$tmptarfile,$sysobj);

    $filepath = $prod->{nicconf}->{filepath};
    $tmptarfile = "$filepath/conf.tar";
    $sys->cmd("cd $filepath; _cmd_tar --exclude=\"version.conf\" -cvf $tmptarfile *");
    
    for my $system (@{$syslist}) {
        next if ($system->{sys} eq $sys->{sys});
        $sys->copy_to_sys($system,$tmptarfile);
        $system->cmd("cd $filepath; _cmd_tar -xvf $tmptarfile && _cmd_rmr $tmptarfile 2>/dev/null");
        # Also copy /etc/hosts file to other node
        $sys->copy_to_sys($system,$prod->{hostsfile});
    }
    $sys->cmd("cd $filepath; _cmd_rmr $tmptarfile 2>/dev/null");
    return;
}

sub addnode_messages {
    my $prod = shift;
    my $pdfrs=Msg::get('pdfrs');
    my($msg);
    my $cprod=CPIC::get('prod');
    $prod = $prod->prod($cprod);

    # display messages
    $msg = Msg::new("Following are the prerequisites to add a node to the cluster:\n");
    $msg->print;
    $msg = Msg::new("\t* The cluster to which you want to add the node must have all required $prod->{abbr} $pdfrs installed\n");
    $msg->print;
    $msg = Msg::new("\t* $prod->{abbr} must be running on the cluster to which you want to add a node\n");
    $msg->print;
    $msg = Msg::new("Refer to the $prod->{abbr} Installation Guide for more details\n");
    $msg->print; 
    Msg::prtc();
    return;
}

sub addnode_get_cluster {
    my $prod = shift;

    # Check cluster status in VCS level
    $prod->perform_task('addnode_get_cluster');
}

sub addnode_get_newnode {
    my $prod = shift;
    my ($conf,$sys,@syslist,@newnodes,@clustersys,@allnodes);

    my $edr = Obj::edr();
    my $cpic= Obj::cpic();
    my $cfg = Obj::cfg();

    # Use default password to establish transport with new nodes
    for my $sysi (@{$cfg->{newnodes}}) {
        $sys = ($Obj::pool{"Sys::$sysi"}) ? Obj::sys($sysi) : Sys->new($sysi);
        if (!$edr->transport_sys($sys)) {
            $conf->{$sysi}{transport_setup_method} = 'ssh';
            $conf->{$sysi}{transport_setup_passwd} = 'root123';
            push (@syslist, $sys);
        }
        push (@newnodes, $sys);
    }
    $edr->setup_transports(\@syslist, $conf) if (@syslist);
    for my $sysi (@{$cfg->{clustersystems}}) {
        $sys = ($Obj::pool{"Sys::$sysi"}) ? Obj::sys($sysi) : Sys->new($sysi);
        push(@clustersys, $sys);
    }
    push (@allnodes, @clustersys, @newnodes);
    $prod->ssh_com_setup(\@allnodes);
    $cpic->{systems} = $edr->init_sys_objects();
    $edr->{systems} = $cpic->{systems};
    $prod->reinstall_newnodes();

    # To compare with the nic status of new node(s) in later step
    $prod->cluster_nic_status();
    # To get the ip availability status in the cluster
    # and also DNS & Gateway status
    $prod->cluster_net_status();
    # TBD: PCI exclution id's need to be read to $cfg->{snas_pciexclusionid}
    $prod->cluster_pciexclusion_status();

    $prod->phase_detect_nic_ip();
}

sub reinstall_newnodes {
    my $prod = @_;
    my @subs;

    my $cpic = Obj::cpic();
    Cfg::set_opt('uninstall');
    @subs = qw(set_pkgs shutdown uninstall);
    $cpic->run_subs(@subs);
    Cfg::unset_opt('uninstall');
    for my $sys (@{$cpic->{systems}}) {
        undef $sys->{pkgvers};
    }
    Cfg::set_opt('install');
    Cfg::set_opt('vxkeyless');
    @subs = qw(systems set_pkgs install licensing);
    $cpic->run_subs(@subs);
    Cfg::unset_opt('install');
}

sub cluster_nic_status {
    my $prod = shift;
    my ($sysi,$sys0,$output,@nics,$nprivnics,$npubnics);

    my $cfg = Obj::cfg();
    $sysi = @{$cfg->{clustersystems}}[0];
    $sys0 = ($Obj::pool{"Sys::$sysi"}) ? Obj::sys($sysi) : Sys->new($sysi);
    $output = $sys0->cmd("_cmd_ifconfig -a 2>/dev/null | _cmd_awk '/Ethernet/ {print \$1}' | _cmd_awk -F: '{print \$1}' | _cmd_sort -u 2>/dev/null");
    @nics = split(/\n/, $output);
    $nprivnics = grep /^$prod->{privnic_prefix}/,@nics;
    $npubnics = grep /^$prod->{pubnic_prefix}/,@nics;
    $sys0->set_value('npublicnics',$npubnics);
    $sys0->set_value('nprivenics',$nprivnics);
}

sub cluster_net_status {
    my ($prod) = @_;
    my ($sysi,$sys0,$padv,$pip,$pipnetmask,$vip,$vipnetmask,$output,@freeip);

    my $cfg = Obj::cfg();
    $sysi = @{$cfg->{clustersystems}}[0];
    $sys0 = ($Obj::pool{"Sys::$sysi"}) ? Obj::sys($sysi) : Sys->new($sysi);

    # cluster DNS & gateway
    $padv=$sys0->padv;
    $cfg->{snas_defgateway} = $padv->get_gateway_sys($sys0,$prod->{netproto});
    $cfg->{snas_dnsip} = $padv->get_dns_sys($sys0);
    $cfg->{snas_dnsdomainname} = $padv->get_domain_sys($sys0);

    $output = $sys0->cmd("_cmd_cat $prod->{nicconf}{physicalipfile} | _cmd_awk '{if(NF==4) print}' | _cmd_tail -n1 2>/dev/null");
    ($pip,$pipnetmask,undef,undef) = split (/\s+/,$output);
    $output = $sys0->cmd("_cmd_cat $prod->{nicconf}{vipfile} | _cmd_awk '{if(NF==2) print}' | _cmd_tail -n1 2>/dev/null");
    ($vip,$vipnetmask) = split (/\s+/,$output);
    $output = $sys0->cmd("_cmd_awk '{if(NF==2)print \$1}' $prod->{nicconf}{privateipfile} 2>/dev/null");
    @freeip = split (/\n/,$output);
    $prod->{priviparr} = \@freeip;
    
    # Find usable ip from the last ip been used & configured in the conf file
    # Used by handler_check_ip in later steps to detect IP availability for new nodes
    $cfg->{snas_pipstart} = $prod->get_next_ip($pip,1);
    $cfg->{snas_pnmaskstart} = $pipnetmask;
    $cfg->{snas_vipstart} = $prod->get_next_ip($vip,1);
    $cfg->{snas_vnmaskstart} = $vipnetmask;
}

sub cluster_pciexclusion_status {
    my ($prod) = @_;
    my ($sys0);

    my $cfg = Obj::cfg();
    $sys0 = Obj::sys(@{$cfg->{clustersystems}}[0]);
    return;
    #FIXME: Need to read net_pci_exclusion.conf for pci exclusion
   # $sys0->cmd("_cmd_grep $prod->{nicconf}->{nasinstallconf} 2>/dev/null");
}

sub addnode_compare_systems {
    my $prod = shift;
    my ($rtn,$sysi,$sys0,$msg);

    my $cfg = Obj::cfg();
    $sysi = @{$cfg->{clustersystems}}[0];
    $sys0 = Obj::sys($sysi);

    $rtn = $prod->nicnum_consistency_check($sys0);
    if ($rtn) {
        $msg = Msg::new("Please make sure the new node has the same public and private NIC as the cluster");
        $msg->error();
    }
    $prod->perform_task('addnode_compare_systems');
}

sub nicnum_consistency_check {
    my ($prod,$sys) = @_;
    my ($npubnics,$nprivnics);

    my $cpic = Obj::cpic();
    # For add node to init the required pub/priv nics number
    if ($sys) {
        $npubnics = $sys->{npublicnics};
        $nprivnics = $sys->{nprivenics};
        return 2 unless ($npubnics && $nprivnics);
    }
    # For install
    for my $sys (@{$cpic->{systems}}) {
        unless ($npubnics && $nprivnics) {
            $npubnics = $sys->{npublicnics};
            $nprivnics = $sys->{nprivenics};
            next;
        }
        next if (($npubnics == $sys->{npublicnics}) &&
                    ($nprivnics == $sys->{nprivenics}));
        # Return error if the pub/priv nics don't equal to that in other nodes
        return 1;
    }
    return 0;
}

sub privnics_link_status_sys {
    my ($prod,$sys,$privnic_maclist) = @_;
    my ($sysi,$sys0,@privniclist,$output,@pidarr,$pid,$rtn,$padv,$msg,$mac);

    my $cfg = Obj::cfg();
    @pidarr = ();
    $sysi = @{$cfg->{clustersystems}}[0];
    $sys0 = Obj::sys($sysi);
    if (!$privnic_maclist) {
        $prod->get_privnics_mac_sys($sys0);
        $privnic_maclist = $sys0->{privnicmac};
    }

    for my $nic (@{$privnic_maclist}) {
        # start dlpiping server in the master node
        $output = $sys0->cmd("_cmd_dlpiping -s $nic 2>/dev/null &");
        (undef,$pid)=split(/\s+/,$output);
        push(@pidarr, $pid);
    }

    @privniclist = $sys->{unpingnics};
    for my $nic (keys %{$privnic_maclist}) {
        $mac = $privnic_maclist->{$nic};
        for my $privnic (@privniclist) {
            next if (defined $sys->{privnic_newname}{$privnic});
            $sys->cmd("_cmd_ifconfig $privnic up; _cmd_sleep 2");
            # Utilize dlpiping client to detect the private nic connection status
            $rtn = $sys->cmd("_cmd_dlpiping -t5 -c $privnic $mac 2>/dev/null");
            unless ($rtn) {
                # Need to update publicnics/privenics
                $sys->{privnic_newname}{$privnic} = $nic;
                last;
            }
        }
    }

    $padv = $sys0->padv;
    @pidarr = $padv->kill_pids_sys($sys0,@pidarr);
    if (@pidarr) {
        $output = join(' ', @pidarr);
        $msg = Msg::log("Some dlpiping server processes are failed to kill: $output");
    }
}

sub get_privnics_mac_sys {
    my ($prod,$sys) = @_;
    my ($output,$privnicpre,@privnic,$mac,$padv);

    $padv=$sys->padv;
    $privnicpre = $prod->{privnic_prefix};
    $output = $sys->cmd("_cmd_ip link show 2>/dev/null | _cmd_awk -F': ' '/^[0-9]*: \$privnicpre/ {print \$2}'");
    @privnic = split (/\n/, $output);
    for my $nic (@privnic) {
        $mac = $padv->get_mac_by_nic_sys($sys,$nic);
        $sys->{privnicmac}{$nic} = $mac;
    }
}

sub addnode_preconfig_newnode {
    my $prod = shift;
    my ($msg);

    for my $sys(@{CPIC::get('systems')}) {
        $prod->copy_crontab_sys($sys);
    }
    $prod->buildup_config_info();
    $prod->phase_config_nic_ip_hostname();
    $prod->write_nasinstallconf();
    # restart NICs solution(without system rebooting) to 
    # enable the nic renaming & ip re-assignment
    $prod->handler_restart_network();
    # init lltlink* and lltlinklowpri* based on the config of the cluster
    $prod->init_llt_nic_conf();
    for my $sys(@{CPIC::get('systems')}) {
        $msg = Msg::new("Node $sys->{newhostname}( $sys->{sys} ) joining cluster");
        $msg->left;
        $sys->cmd("$prod->{installerdir}/installer -m join 2>/dev/null");
        $msg->right_done;
    }
}

sub addnode_config_snas {
    my $prod = shift;

    for my $sys(@{CPIC::get('systems')}) {
        $sys->cmd("_cmd_vxddladm set namingscheme=ebn persistence=yes");
        # FIXME: Need confirm if it's needed, as existing addnode can do scan disks already
        #$sys->cmd("$prod->{storscriptsdir}/scanbus.sh  2>/dev/null");
    }
}

sub addnode_init_new_hostname {
    my $prod = shift;
    my ($sysi,$sys0,$sys,$clusname,@used_nids,$n,$hostid);

    my $cfg = Obj::cfg();
    my $vcs = $prod->prod('VCS61');
    $sysi = @{$cfg->{clustersystems}}[0];
    $sys0 = Obj::sys($sysi);
    $clusname = $sys0->{vcs_conf}{clustername};
    if (!$clusname) {
        $clusname = $sys0->cmd("_cmd_grep '^cluster' $vcs->{maincf} 2> /dev/null | _cmd_awk '{print \$2}'");
    }
    
    $n = 0;
    @used_nids = split(/\n/, $sys0->cmd("_cmd_cat $vcs->{llthosts} | _cmd_awk '! /^[ \t]\$/ {print \$1}' 2>/dev/null"));
    for my $system (@{$cfg->{newnodes}}) {
        while (EDRu::inarr($n, @used_nids)) {
            $n++;
        }
        $sys = Obj::sys($system);
        $hostid = $n + 1;
        if ($hostid < 10) {
            $sys->{newhostname} = $clusname."_0".$hostid;
        } else {
            $sys->{newhostname} = $clusname."_".$hostid;
        }
        push (@used_nids, $n);
        $n++;
    }
    return;
}

sub addnode_write_config_files_sys {
    my ($prod,$sys) = @_;
    my $cfg = Obj::cfg();

    my @physicaliparr =@{$prod->{physicaliparr}};
    my @privateiparr = @{$prod->{privateiparr}};
    my @viparr = @{$prod->{viparr}};
    my @iphostsarr = @{$prod->{iphostsarr}};

    $sys->mkdir($prod->{nicconf}->{filepath});
    $prod->set_physicalipfile_sys($sys,@physicaliparr);
    $prod->set_privateipfile_sys($sys,@privateiparr);
    $prod->set_vipfile_sys($sys,@viparr);
    $prod->set_globalroutesfile_sys($sys);
    $prod->update_hosts_file_sys($sys,@iphostsarr);

    return 1;
}

sub init_llt_nic_conf {
    my ($prod) = shift;
    my ($conf,$sysi,$sys0,$n,$sys);

    my $cfg = Obj::cfg();
    my $vcs = $prod->prod('VCS61');
    $sysi = @{$cfg->{clustersystems}}[0];
    $sys0 = Obj::sys($sysi);
    $conf = $vcs->get_config_sys($sys0);
    for my $sysi (@{$cfg->{newnodes}}) {
        $sys = Obj::sys($sysi);
        $n = 1;
        while (defined $conf->{"lltlink$n"}{$sys0->{sys}}) {
            $cfg->{"vcs_lltlink$n"}{$sysi} = $conf->{"lltlink$n"}{$sys0->{sys}};
            $n++;
        }
        $n = 1;
        while (defined $conf->{"lltlinklowpri$n"}{$sys0->{sys}}) {
            $cfg->{"vcs_lltlinklowpri$n"}{$sysi} = $conf->{"lltlinklowpri$n"}{$sys0->{sys}};
            $n++;
        }
    }
    return;
}

sub addnode_configure_cluster {
    my ($prod) = shift;
    $prod->perform_task('addnode_configure_cluster');
}

sub addnode_poststart {
    my ($prod) = shift;
    my $sfcfsha = $prod->prod('SFCFSHA61');
    $prod->addnode_config_groups();
    $sfcfsha->addnode_poststart();
    # TBD: shell script called, should be re-implemented with perl
#    $prod->addnode_config_cifs();
    $prod->create_disk_info_file();
    $prod->set_tunables();
    $prod->dmp_exclude_local_disk();
    $prod->config_gui();
    return;
}

# Need to do it in dependency order
sub addnode_config_groups {
    my ($prod) = shift;
    my ($sys0,$conf,$allsg,$sys);

    my $cfg = Obj::cfg();
    my $vcs = $prod->prod('VCS61');
    $sys0 = Obj::sys(${$cfg->{clustersystems}}[0]);
    $conf = $vcs->get_config_sys($sys0);
    $allsg = $conf->{groups};

    $prod->{configured} = ();
    $vcs->haconf_makerw();
    for my $sysi (@{$cfg->{newnodes}}) {
        $sys = Prod::VCS61::Common::transform_system_name($sysi);
        $prod->addnode_config_group($allsg, $sys);
    }
    $vcs->haconf_dumpmakero();
    delete($prod->{configured});
    return;
}

sub addnode_config_group {
    my ($prod,$sgs,$sysname) = @_;
    my ($sys0,$depsgs,@depsgarr,$rtn,$max_pri);

    my $cfg = Obj::cfg();
    my $vcs = $prod->prod('VCS61');
    $sys0 = Obj::sys(${$cfg->{clustersystems}}[0]);

    for my $sg(@{$sgs}) {
        next if (defined $prod->{configured}{$sg});
        $depsgs = $sys0->cmd("$vcs->{bindir}/hagrp -dep $sg 2>/dev/null | _cmd_grep '^$sg' | _cmd_awk '{print \$2}'");
        if ($depsgs) {
            @depsgarr = split(/\s+/, $depsgs);
            $prod->addnode_config_group(\@depsgarr,$sysname);
        }
        $max_pri = $vcs->get_sg_max_priority($sg);
        $max_pri+=1;
        $rtn = $sys0->cmd("$vcs->{bindir}/hagrp -modify $sg SystemList -add $sysname $max_pri");
        if(EDRu::isverror($rtn)) {
            Msg::log("Modify $sg SystemList to add $sysname failed.");
        }

        $rtn = $sys0->cmd("$vcs->{bindir}/hagrp -value $sg Enabled");
        $sys0->cmd("$vcs->{bindir}/hagrp -disable $sg -sys $sysname") unless ($rtn);

        $rtn = $sys0->cmd("$vcs->{bindir}/hagrp -value $sg AutoStartList");
        if ($rtn) {
            $rtn = $sys0->cmd("$vcs->{bindir}/hagrp -modify $sg AutoStartList -add $sysname");
            if (EDRu::isverror($rtn)) {
                Msg::log("Modify $sg AutoStartList to add $sysname failed");
            }
        }

        $rtn = $sys0->cmd("$vcs->{bindir}/hagrp -value $sg PreOnline");
        if ($rtn == 1) {
            $rtn = $sys0->cmd("$vcs->{bindir}/hagrp -modify $sg PreOnline 1 -sys $sysname");
        }
        $prod->{configured}{$sg} = 1;
    }
}

sub addnode_config_cifs {
    my $prod = shift;
    my ($sys0,$ctdblog,$sys);

    my $cfg = Obj::cfg();
    $sys0 = Obj::sys(${$cfg->{clustersystems}}[0]);
    $sys0->cmd(". $prod->{libscriptsdir}/ctdb_lib.sh; ctdb_create_private_ip_file");

    $ctdblog = "$prod->{logdir}/ctdb.log";
    for my $sysi(@{$cfg->{newnodes}}) {
        $sys = Obj::sys($sysi);
        $sys->mkdir("/var/ctdb");
        $sys->mkdir("/var/ctdb/state");
        $sys->cmd(". $prod->{libscriptsdir}/cifs_lib.sh; gen_smb_conf >> $ctdblog 2>>$ctdblog");
    }
}

sub create_disk_info_file {
    my $prod = shift;
    my $sys;
    my $cfg = Obj::cfg();
    for my $sysi(@{$cfg->{newnodes}}) {
        $sys = Obj::sys($sysi);
        $sys->cmd("$prod->{storscriptsdir}/create_disks_info.sh");
    }
}

sub set_tunables {
    my $prod = shift;
    my ($sys0,$dmppolicy,$sys);

    my $cfg = Obj::cfg();
    $sys0 = Obj::sys(${$cfg->{clustersystems}}[0]);
    $dmppolicy = "/etc/vx/dmppolicy.info";
    for my $sysi(@{$cfg->{newnodes}}) {
        $sys = Obj::sys($sysi);
        $sys0->copy_to_sys($sys,$dmppolicy);
        # TBD: Script is not OK yet
#        $sys0->cmd("$prod->{sysscriptsdir}/optionconfig.sh nodeadd $sys->{sys}");
    }
}

sub dmp_exclude_local_disk {
    my $prod = shift;
    # TBD
}

sub config_gui {
    my $prod = shift;
    # TBD
}

sub copy_crontab_sys {
    my ($prod,$sys) = @_;
    my ($sys0,$output,@consarr,@tmpfilearr,$curr_cons,$curr_tmpfile);

    my $cfg = Obj::cfg();
    push(@consarr, "dst_policy.sh enforce");
    push(@consarr, "autosnap_policy.sh create");
    push(@tmpfilearr, "/tmp/local_cron.txt");
    push(@tmpfilearr, "/tmp/local_autosnap.txt");
    $sys0 = Obj::sys(${$cfg->{clustersystems}}[0]);
    
    for my $n (0..1) {
        $curr_cons = @consarr[$n];
        $curr_tmpfile = @tmpfilearr[$n];
        $output = $sys0->cmd("_cmd_crontab -l 2>/dev/null | _cmd_grep -v '^#' | _cmd_grep '\$curr_cons'");
        $sys->cmd("_cmd_crontab -l 2>/dev/null | _cmd_grep -v '^#' | _cmd_grep -v '\$curr_cons' > \$curr_tmpfile");
        $sys->appendfile($output,$curr_tmpfile);
        $sys->cmd("_cmd_crontab $curr_tmpfile >/dev/null 2>&1");
    }
    return;
}

sub perform_task {
    my ($prod,$task) = @_;

    my $vcs = $prod->prod('VCS61');
    $vcs->$task() if ($vcs->can($task));
    return;
}

sub install_thirdparty_pkgs_sys {
    my ($prod,$sys, $thirdpartypkgs_aref) = (@_);
    my ($cpic,$file,$guirpm_dir,$iof,$msg,$rpm,$ret,$tmpdir);
    $cpic = Obj::cpic();
    $guirpm_dir = $prod->{gui_rpm_dir};
    $tmpdir=EDR::tmpdir();

    Msg::log("Installing perl template rpms on $sys->{sys}");
    if (!-d "$cpic->{mediapath}/$guirpm_dir") {
        Msg::log("No $guirpm_dir dir exists, do not install the perl-Template rpm");
        return;
    }
    for my $pkg_ver(@$thirdpartypkgs_aref) {
        my ($pkg,$ver) = split(/\s+/, $pkg_ver);
        $file = EDR::cmd_local("_cmd_ls $cpic->{mediapath}/$guirpm_dir/$pkg* 2>/dev/null");
        chomp($file);
        if (!-f $file) {
            Msg::log("No $file exists, do not install the perl-Template rpm");
            next;
        }
        $msg = Msg::new("Installing $pkg on $sys->{sys}");
        $msg->left;
        $rpm = ($sys->{islocal}) ? $file : "$tmpdir/". EDRu::basename($file);
        $prod->localsys->copy_to_sys($sys,$file,$tmpdir) if (!$sys->{islocal});
        $iof=EDRu::outputfile('install', $sys->{sys}, EDRu::basename($file));
        $sys->cmd("_cmd_rpm -U -v --nodeps $rpm 2>$iof 1>&2");
        if (EDR::cmdexit()) {
            $msg->right_failed;
        } else {
            $msg->right_done;
            $ret = 1;
        }
    }

    return $ret;
}

sub postinstall_sys {
    my ($prod,$sys) = (@_);
    my (@files,$cpic,$guirpm_dir);
    $cpic = Obj::cpic();

    if ($sys->{store_release_imgs}{base_img}) {
        $prod->copy_img_to_sys($sys, 'base');
        delete $sys->{store_release_imgs}{base_img};
    }
    if ($sys->{store_release_imgs}{mr_img}) {
        $prod->copy_img_to_sys($sys, 'mr');
        delete $sys->{store_release_imgs}{mr_img};
    }
    if ($sys->{store_release_imgs}{hf_img}) {
        $prod->copy_img_to_sys($sys, 'hf');
        delete $sys->{store_release_imgs}{hf_img};
    }
    $prod->del_obsoloted_img_sys($sys);
    $prod->update_preference_file_sys($sys);

    $guirpm_dir = $prod->{gui_rpm_dir};

    Msg::log("Copying gui jar files and tar files on $sys->{sys}");
    if (!-d "$cpic->{mediapath}/$guirpm_dir") {
        Msg::log("No $guirpm_dir dir exists, do not copy the gui tar files");
        return;
    }
    $sys->mkdir($prod->{gui_lib_dir});
    $sys->mkdir($prod->{gui_install_dir});
    @files = glob("$cpic->{mediapath}/$guirpm_dir/*");
    for my $file(@files) {
        if ($file =~ /\.jar/m) {
            $prod->localsys->copy_to_sys($sys,$file,$prod->{gui_lib_dir});
        } elsif ($file =~ /\.tar/m) {
            Msg::log("Copying $file to $prod->{gui_install_dir}");
            $prod->localsys->copy_to_sys($sys,$file,$prod->{gui_install_dir});
        }
    }

    $prod->perform_task_sys($sys,'postinstall_sys');
    return;
}
sub create_responsefile {
    my ($prod, $cfg, $resfile) = @_;
    my $rf;
    my $syslist;

    $syslist = CPIC::get('systems');
    my @systems;
    for my $system (@$syslist) {
        push(@systems, $system->{sys});
    }

    $cfg->{opt}{install} = 1;
    $cfg->{opt}{gco} = 1;
    $cfg->{opt}{accepteula} = 1;
    $cfg->{opt}{installallpkgs} = 1;
    $cfg->{opt}{noipc} = 1;
    $cfg->{opt}{updatekeys} = 1;
    $cfg->{opt}{vxkeyless} = 1;
    $cfg->{prod} = "SNAS60";
    $cfg->{systems} = \@systems;

    $rf="#\n# Configuration Values:\n#\nour \%CFG;\n\n".EDRu::hash2def($cfg, 'CFG')."\n1;\n";

    EDRu::writefile($rf, "$resfile");

    return 1;
}

sub addnode_install_sys {
    my ($prod, $sys) = @_;
    my ($repository_path, $base_version, $mr_version, $hf_version, $base_path, $mr_path, $hf_path);
    my ($basecmd, $hfcmd, $cmd, $msg, $syslist);
    my $tmpdir = EDR::get('tmpdir');
    my $resfile = "$tmpdir/addnode_install.res";
    my $localsys = Obj::edr()->{localsys};
    my $cfg;

    $prod->read_preference_file_sys($localsys);
    $repository_path = $prod->get_repository_on_sys($localsys);

    if ($localsys->{store_release_imgs}{"InstalledBase"}) {
        $base_version = $localsys->{store_release_imgs}{"InstalledBase"};
        $base_path = "$repository_path/ga/images/SSNAS/$base_version";
        if (!$prod->img_stored_on_sys($localsys, $base_path)) {
            $msg = Msg::new("SNAS $base_version is not stored on $localsys->{sys}, can not install SNAS $base_version on $sys->{sys}");
            $msg->die();
        }
    } 
    if ($localsys->{store_release_imgs}{"InstalledMR"}) {
        $mr_version = $localsys->{store_release_imgs}{"InstalledMR"};
        $mr_path = "$repository_path/mr/images/SSNAS/$mr_version";
        if (!$prod->img_stored_on_sys($localsys, $mr_path)) {
            $msg = Msg::new("SNAS $mr_version is not stored on $localsys->{sys}, can not install SNAS $mr_version on $sys->{sys}");
            $msg->die();
        }
    }
    if ($localsys->{store_release_imgs}{"InstalledHF"}) {
        $hf_version = $localsys->{store_release_imgs}{"InstalledHF"};
        $hf_path = "$repository_path/hf/images/SSNAS/$hf_version";
        if (!$prod->img_stored_on_sys($localsys, $hf_path)) {
            $msg = Msg::new("SNAS $hf_version is not stored on $localsys->{sys}, can not install SNAS $hf_version on $sys->{sys}");
            $msg->die();
        }
    }

    if ($mr_version) {
        if ($base_version) {
            $cfg->{base_path} = $base_path;
        }
        if ($hf_version) {
            $cfg->{hotfix_path} = $hf_path;
        }
        $cmd = "$mr_path/installmr";
    } elsif ($base_version) {
        if ($hf_version) {
            $cfg->{hotfix_path} = $hf_path;
        }
        $cmd = "$base_path/installer";
    } else {
        Msg::die("No base or Maintenance release installed on $localsys->{sys}");
    }

    $prod->create_responsefile($cfg, $resfile);

    $cmd .= " -responsefile $resfile";

    $msg=Msg::new("\nExecuting the following command to start installation of SNAS on $sys->{sys}:\n\n\t$cmd\n");
    $msg->bold();

    system($cmd);
}

# set up passwordless communication for root between the systems
sub ssh_com_setup {
    my ($prod, $systems_aref) = (@_);
    my (@systems,@keyfiles,$homedir);
    my ($authorized_keys_file,$keyfile,$keyfile_public,$knownhosts,$ssh_dir,$sshkey,$sshkeys,$user);

    $homedir = '/root';
    $user = 'root';
    $ssh_dir = "$homedir/.ssh";
    $authorized_keys_file = "$ssh_dir/authorized_keys";
    @systems = @$systems_aref;
    @keyfiles=();
    $keyfile = Cfg::opt('keyfile');
    push(@keyfiles, $keyfile) if ($keyfile);
    push(@keyfiles, "$homedir/.ssh/id_rsa");
    push(@keyfiles, "$homedir/.ssh/id_dsa");

    $sshkeys = '';
    $knownhosts = '';
    for my $sys(@systems) {
        $sys->cmd("/etc/init.d/sshd start");

        $keyfile='';
        $keyfile_public='';
        for my $file (@keyfiles) {
            if ($sys->exists($file) && $sys->exists("$file".'.pub')) {
                $keyfile=$file;
                $keyfile_public="$file".'.pub';
                last;
            }
        }
        if (!$keyfile) {
            Msg::log("No existing ssh keyfile on $sys->{sys}, generate new keys");
            $keyfile="$homedir/.ssh/id_rsa";
            $keyfile_public=$keyfile.'.pub';
            $sys->cmd("_cmd_sshkeygen -q -t rsa -N \'\' -f $keyfile 2>/dev/null");
        }

        if ($sys->exists("$keyfile")) {
            $sshkey = $sys->readfile($keyfile_public);
            $sshkeys .= "$sshkey";
        }
        if ($sys->{newhostname}) {
            $knownhosts .= "$sys->{sys},$sys->{newhostname} ";
        } else {
            $knownhosts .= "$sys->{sys} ";
        }
    }

    for my $sys(@systems) {
        Msg::log("Adding all ssh keys to authorized_keys on $sys->{sys} and generate entries in known_hosts file");
        $sys->cmd("_cmd_mkdir -p $ssh_dir; _cmd_chmod 0700 $ssh_dir; _cmd_chown $user $ssh_dir");
        $sys->appendfile($sshkeys, $authorized_keys_file);
        $sys->cmd("_cmd_chmod 0600 $authorized_keys_file; _cmd_chown $user $authorized_keys_file; /sbin/restorecon -v $authorized_keys_file");
        $sys->cmd("_cmd_sshkeyscan -t rsa $knownhosts > $ssh_dir/known_hosts 2>/dev/null");
    }

    # set comsetup option so that it will not be cleaned up
    Cfg::set_opt('comsetup');

    return;
}

package Prod::SNAS60::SunOS;
@Prod::SNAS60::SunOS::ISA = qw(Prod::SNAS60::Common);

1;
