#
# $Copyright: Copyright (c) 2014 Symantec Corporation.
# All rights reserved.
#
# THIS SOFTWARE CONTAINS CONFIDENTIAL INFORMATION AND TRADE SECRETS OF
# SYMANTEC CORPORATION.  USE, DISCLOSURE OR REPRODUCTION IS PROHIBITED
# WITHOUT THE PRIOR EXPRESS WRITTEN PERMISSION OF SYMANTEC CORPORATION.
#
# The Licensed Software and Documentation are deemed to be commercial
# computer software as defined in FAR 12.212 and subject to restricted
# rights as defined in FAR Section 52.227-19 "Commercial Computer
# Software - Restricted Rights" and DFARS 227.7202, "Rights in
# Commercial Computer Software or Commercial Computer Software
# Documentation", as applicable, and any successor regulations. Any use,
# modification, reproduction release, performance, display or disclosure
# of the Licensed Software and Documentation by the U.S. Government
# shall be solely in accordance with the terms of this Agreement.  $
#
use strict;

package Prod::SNAS60::Common;
@Prod::SNAS60::Common::ISA = qw(Prod::SFCFSHA61::Common);

sub responsefile_prestart_config {
    my ($prod) = @_;
    my ($ret,$msg,$cpic);
    $cpic=Obj::cpic();
    $ret = $prod->op_nic_hostname();
    if ($ret == 0 || $ret == 2) {
        $msg = Msg::new("NIC detecting error, please double check the enviroment.");
        $msg->error();
        $cpic->edr_completion();
        return; 
    }
    $prod->perform_task('responsefile_prestart_config');
    return;
}

package Prod::SNAS60::AIX;
@Prod::SNAS60::AIX::ISA = qw(Prod::SNAS60::Common);

package Prod::SNAS60::HPUX;
@Prod::SNAS60::HPUX::ISA = qw(Prod::SNAS60::Common);

package Prod::SNAS60::Linux;
@Prod::SNAS60::Linux::ISA = qw(Prod::SNAS60::Common);

package Prod::SNAS60::RHEL5x8664;
@Prod::SNAS60::RHEL5x8664::ISA = qw(Prod::SNAS60::Linux);

package Prod::SNAS60::RHEL6x8664;
@Prod::SNAS60::RHEL6x8664::ISA = qw(Prod::SNAS60::Linux);

sub init_padv {
    my $prod=shift;
    $prod->{name}=Msg::new("Symantec Storage NAS")->{msg};
    $prod->{prod}='SNAS';
    $prod->{abbr}='SNAS';
    $prod->{proddir}='symantec_storage_nas';
    $prod->{menu_options}=['Veritas Volume Replicator','Global Cluster Option'];
    $prod->{eula}='EULA_SFHA_Ux_6.1.pdf';
    $prod->{allpkgs}=[ qw(VRTSglm61 VRTScavf61 VRTSgms61 VRTSdbms330 SYMCsnas60) ];
    $prod->{minpkgs}=[ qw(VRTSglm61 VRTScavf61 VRTSdbms330 SYMCsnas60) ];
    $prod->{recpkgs}=[ qw(VRTSglm61 VRTScavf61 VRTSgms61 VRTSdbms330 SYMCsnas60) ];

    $prod->{lic_names}=['Storage Foundation for Cluster File System'];

    $prod->{installscript_prod}='SNAS60';
    $prod->{installscript_name}='SNAS';
    $prod->{mainpkg}='VRTScavf61';
    $prod->{installallpkgs} = 1;

    $prod->{extra_mainpkgs}=[ qw(VRTSvxvm61 VRTSvxfs61 VRTSvcs61 VRTSllt61 VRTSgab61 VRTSvxfen61 VRTSvcsag61)];

    $prod->{installerdir}='/opt/SYMCsnas/install/image_install';
    $prod->{nicconf}->{filepath} = "/opt/SYMCsnas/conf/";
    $prod->{nicconf}->{nodefilepath} = "/opt/SYMCsnas/nodeconf/";
    $prod->{nicconf}->{physicalipfile}="/opt/SYMCsnas/conf/net_pip_list.conf";
    $prod->{nicconf}->{publicdevicefile}="/opt/SYMCsnas/conf/net_pub_dev_list.conf";
    $prod->{nicconf}->{privatedevicefile}="/opt/SYMCsnas/conf/net_priv_dev.conf";
    $prod->{nicconf}->{privateipfile}="/opt/SYMCsnas/conf/net_priv_ip_list.conf";
    $prod->{nicconf}->{vipfile}="/opt/SYMCsnas/conf/net_vip_list.conf";
    $prod->{nicconf}->{vipdevicefile}="/opt/SYMCsnas/conf/net_vip_dev_list.conf";
    $prod->{nicconf}->{consoleipfile}="/opt/SYMCsnas/conf/net_console_ip.conf";
    $prod->{nicconf}->{consoledevfile}="/opt/SYMCsnas/conf/net_console_dev.conf";
    $prod->{nicconf}->{nasinstallconf}="/opt/SYMCsnas/nodeconf/nasinstall.conf";
    $prod->{nicconf}->{udevconffile}="/etc/udev/rules.d/70-persistent-net.rules";
    $prod->{nicconf}->{globalroutes}="/opt/SYMCsnas/conf/net_globalroutes.conf";
    $prod->{nicconf}->{rcscriptpath}="/etc/rc.d/rc.local";
    $prod->{nicconf}->{rcscript}="/tmp/nicscript.sh";
    $prod->{clish}->{clishhomepath}="/home/clish";
    $prod->{clish}->{bashpath}="/bin/bash";
    $prod->{clish}->{clishpath}="/opt/SYMCsnas/clish/bin/clish";
    $prod->{clish}->{supporthomepath}="/home/support";
    $prod->{netproto}="ipv4";
    $prod->{netprotovip}="ipv4";
    $prod->{netprotoipv4}="ipv4";
    $prod->{netprotoipv6}="ipv6";
    $prod->{hostsfile}='/etc/hosts';
    $prod->{fatal_error_key}="STOP";
    $prod->{ip_error_key}="IPERROR";
    $prod->{mode}->{master}="new";
    $prod->{mode}->{slave}="join";
    $prod->{minimum_pub_nic_num}=1;
    $prod->{mininum_priv_nic_num}=1;
    $prod->{max_priv_nic_num}=2;
    $prod->{privateiparr}=['172.16.0.3',
                           '172.16.0.4',
                           '172.16.0.5',
                           '172.16.0.6',
                           '172.16.0.7',
                           '172.16.0.8',
                           '172.16.0.9',
                           '172.16.0.10',
                           '172.16.0.11',
                           '172.16.0.12',
                           '172.16.0.13',
                           '172.16.0.14',
                           '172.16.0.15',
                           '172.16.0.16',
                           '172.16.0.17',
                           '172.16.0.18',
                           '172.16.0.19'];

    $prod->{privateipnetmask}="255.255.255.0";
    $prod->{store_release_imgs}{config_file} = "/opt/VRTS/.install_pref";
    $prod->{gui_lib_dir} = '/opt/SYMCsnas/gui/third_party_libs';
    $prod->{gui_install_dir} = '/opt/SYMCsnas/gui/install';
    $prod->{gui_rpm_dir} = 'gui_rpms';
    return ;
}

sub set_pkgs {
    my $prod = shift;
    my($category,@categories);

    $prod->SUPER::set_pkgs();
    @categories=qw(minpkgs recpkgs allpkgs);
    for my $category (@categories) {
        $prod->{$category}=EDRu::arrdel($prod->{$category},'VRTSodm61', 'VRTSob34');
    }
    return $prod->{allpkgs};
}

sub preinstall_sys {
    my ($prod, $sys) = @_;

    $prod->SUPER::preinstall_sys($sys);
    $prod->get_imgs_stored_location_sys($sys);
    $prod->check_img_space_sys($sys);
    return;
}

#1. read config file and init $sys->{store_release_imgs}
#2. check if imgs already stored on system. if not stored, prepare to store them after installation.
sub get_imgs_stored_location_sys {
    my ($prod, $sys) = @_;
    my ($cpic, $rel, $repository_path);
    my ($base_path, $base_version, $mr_path, $mr_version, $hf_path, $hf_version, $dest_path);
    $cpic = Obj::cpic();

    $prod->init_preference_sys($sys);
    $repository_path = $prod->get_repository_on_sys($sys);
    $rel = $cpic->rel();
    #get base release image
    if ($rel->{type} =~ /B/) {
        $base_path = Cfg::opt('base_path') || $cpic->{mediapath};
        $base_version = $prod->major_vers($cpic->rel()->{vers});
        $dest_path = "ga/images/SSNAS/$base_version";
        if (!$prod->img_stored_on_sys($sys, "$repository_path/$dest_path")) {
            $sys->{store_release_imgs}{base_img}{from} = $base_path;
            $sys->{store_release_imgs}{base_img}{to} = $dest_path;
        }
        $sys->{store_release_imgs}{"InstalledBase"} = $base_version;
        $sys->{store_release_imgs}{"InstalledMR"} = "";
        $sys->{store_release_imgs}{"InstalledHF"} = "";
    }
    #get mr release image
    if ($rel->{type} =~ /M/) {
        $mr_path = $cpic->{mediapath};
        $mr_version = $cpic->maintenance_release();
        $dest_path = "patch/images/SSNAS/$mr_version";
        if (!$prod->img_stored_on_sys($sys, "$repository_path/$dest_path")) {
            $sys->{store_release_imgs}{mr_img}{from} = $mr_path;
            $sys->{store_release_imgs}{mr_img}{to} = $dest_path;
        }
        $sys->{store_release_imgs}{"InstalledMR"} = $mr_version;
        $sys->{store_release_imgs}{"InstalledHF"} = "";
    }
    #get hotfix release images
    if ($rel->{type} =~ /H/) {
        $hf_path = Cfg::opt("hotfix_path") || $cpic->{mediapath};
        $hf_version = $cpic->rel()->{vers};
        $dest_path =  "hotfix/images/SSNAS/$hf_version";
        if (!$prod->img_stored_on_sys($sys, "$repository_path/$dest_path")) {
            $sys->{store_release_imgs}{hf_img}{from} = $hf_path;
            $sys->{store_release_imgs}{hf_img}{to} = $dest_path;
        }
        $sys->{store_release_imgs}{"InstalledHF"} = $hf_version;
    }
    return 1;
}

sub init_preference_sys {
    my ($prod, $sys) = @_;
    unless($sys->exists($prod->{store_release_imgs}{config_file})) {
        $prod->init_preference_file($sys);
    }
    $prod->read_preference_file_sys($sys);
    return 1;
}

sub read_preference_file_sys {
    my ($prod, $sys) = @_;
    my ($content, $preference_hash);
    my $file = $prod->{store_release_imgs}{config_file};

    if ($sys->exists($file)) {
        $content = $sys->catfile($file);
    } else {
        Msg::die("Reference file $file is not existed on $sys->{sys}")
    }

    $preference_hash = EDRu::eval_json($content);
    for my $key (keys %{$preference_hash}) {
        $sys->{store_release_imgs}{$key} = $preference_hash->{$key};
    }
    return 1;
}

sub update_preference_file_sys {
    my ($prod, $sys) = @_;
    my $preference_file = $prod->{store_release_imgs}{config_file};
    my $content;

    $content = JSON::to_json($sys->{store_release_imgs}, {pretty=>1});
    $sys->writefile($content, $preference_file);
    return 1;
}
#get the repository path forsys 
sub get_repository_on_sys {
    my ($prod, $sys) = @_;
    my $msg;
    if ($sys->{store_release_imgs}{"Repository"}) {
        return $sys->{store_release_imgs}{"Repository"};
    } else {
        $msg=Msg::new("Cannot find Repository directory on $sys->{sys}");
        $msg->die();
    }
    return 1;
}

sub major_vers {
    my ($prod, $vers) = @_;
    my @vfields = split(/\./m, $vers);
    my ($majorver, $padv);

    $vfields[0] =~ s/\D.*$//m;
    $vfields[0] += 0;
    $vfields[1] =~ s/\D.*$//m;
    $vfields[1] += 0;
    $majorver = join('.', $vfields[0], $vfields[1]);
    return $majorver;
}

#check if image is stored on sys:
#1. img_dir existed
#2. install* script existed under $img_dir
#3. ssn_img.tar is not eixsted under %img_dir
sub img_stored_on_sys {
    my ($prod, $sys, $img_dir) = @_;
    my $tmp_tar = "ssn_img.tar";
    my $msg;
    if ($sys->exists($img_dir) && ($sys->cmd("_cmd_ls $img_dir | _cmd_grep 'install*'"))) {
        if ($sys->exists("$img_dir/$tmp_tar")) {
            Msg::log("$img_dir/$tmp_tar is not removed after last installation. Assume img not existed on $sys->{sys}");
            return 0;
        }
        Msg::log("Img $img_dir existed on $sys->{sys}");
        return 1;
    }
    return 0;
}

sub del_obsoloted_img_sys {
    my ($prod, $sys) = @_;
    my ($installed_base, $installed_mr, $installed_hf, $repository_path);

    $installed_base = $sys->{store_release_imgs}{"InstalledBase"};
    $installed_mr = $sys->{store_release_imgs}{"InstalledMR"};
    $installed_hf = $sys->{store_release_imgs}{"InstalledHF"};
    $repository_path = $prod->get_repository_path($sys);

    #delete base imgs
    my $base_directory = "$repository_path/ga/images/SSNAS/";
    if ($sys->exists($base_directory)) {
        if ($installed_base) {
            $sys->cmd("cd $base_directory; _cmd_ls | _cmd_grep -v $installed_base | xargs _cmd_rmr ")
        } else {
            $sys->cmd("_cmd_rmr $base_directory/*")
        }
    }

    #delete mr imgs
    my $mr_directory = "$repository_path/patch/images/SSNAS/";
    if ($sys->exists($mr_directory)) {
        if ($installed_mr) {
            $sys->cmd("cd $mr_directory; _cmd_ls | _cmd_grep -v $installed_mr | xargs _cmd_rmr ")
        } else {
            $sys->cmd("_cmd_rmr $mr_directory/*")
        }
    }

    #delete hotfix images
    my $hotfix_directory = "$repository_path/hotfix/images/SSNAS/";
    if ($sys->exists($hotfix_directory)) {
        if ($installed_hf) {
            $sys->cmd("cd $hotfix_directory; _cmd_ls | _cmd_grep -v $installed_hf | xargs _cmd_rmr ")
        } else {
            $sys->cmd("_cmd_rmr $hotfix_directory/*")
        }
    }
    return 1;
}

sub get_repository_path {
    my ($prod, $sys) = @_;
    my $msg;
    if ($sys->{store_release_imgs}{"Repository"}) {
        return $sys->{store_release_imgs}{"Repository"};
    } else {
        $msg=Msg::new("Cannot find Repository directory on $sys->{sys}");
        $msg->die();
    }
    return 1;
}

#copy img from localsys to other node
sub copy_img_to_sys {
    my ($prod, $sys, $level) = @_;
    my ($localtmptarfile, $tmptarfile, $repdir, $syslist, $sysobj, $img_exist, $srcpath, $despath);
    my $localsys = Obj::edr()->{localsys};
    my $repository_path;
    my $tmp_tar = "ssn_img.tar";
    my $tmpdir = EDR::get('tmpdir');

    if ($level eq 'base') {
        $srcpath = $sys->{store_release_imgs}{base_img}{from};
        $despath = $sys->{store_release_imgs}{base_img}{to};
    } elsif ($level eq 'mr') {
        $srcpath = $sys->{store_release_imgs}{mr_img}{from};
        $despath = $sys->{store_release_imgs}{mr_img}{to};
    } elsif ($level eq 'hf') {
        $srcpath = $sys->{store_release_imgs}{hf_img}{from};
        $despath = $sys->{store_release_imgs}{hf_img}{to};
    } else {
        Msg::log("level $level is not defined on $sys->{sys}");
        return;
    }

    $repository_path = $prod->get_repository_path($sys);
    $tmptarfile = "$repository_path/$despath/$tmp_tar";
    #make tar file on localsys
    $localtmptarfile = "$tmpdir/$level/$tmp_tar";
    if (!$sys->system1) {
        EDRu::wait_for_flag("make_tmp_tar_$level\_done");
    } else {
        EDRu::mkdir_local_nosys("$tmpdir/$level");
        $localsys->cmd("cd $srcpath; _cmd_tar -cvf $localtmptarfile *");
        EDRu::create_flag("make_tmp_tar_$level\_done");
    }

    if (!$sys->exists("$repository_path/$despath")) {
        $sys->cmd("_cmd_mkdir -p $repository_path/$despath");
    }

    #copy tar file to sys
    $localsys->copy_to_sys($sys,$localtmptarfile,$tmptarfile);

    #untar file on sys
    $sys->cmd("cd $repository_path/$despath; _cmd_tar -xvf $tmptarfile && _cmd_rmr $tmptarfile 2>/dev/null");

    return 1;
}


sub check_img_space_sys {
    my ($prod, $sys) = @_;
    my ($cpic, $free, $img_size, $img_path, $msg, $require_space);
    $cpic = Obj::cpic();
    $free = $cpic->volumespace_sys($sys, '/opt') || $cpic->volumespace_sys($sys, '/');

    if ($sys->{store_release_imgs}{base_img}) {
        $img_path = $sys->{store_reelase_img}{base_img}{from};
        $img_size += $sys->cmd("_cmd_du -sk $img_path");
    }
    if ($sys->{store_release_imgs}{mr_img}) {
        $img_path = $sys->{store_reelase_img}{mr_img}{from};
        $img_size += $sys->cmd("_cmd_du -sk $img_path");
    }
    if ($sys->{store_release_imgs}{hf_img}) {
        $img_path = $sys->{store_reelase_img}{hf_img}{from};
        $img_size += $sys->cmd("_cmd_du -sk $img_path");
    }

    $require_space = $img_size * 3;
    if ($free < $require_space) {
        $msg = Msg::new("Not enough space in /opt on system $sys->{sys}.");
        Msg::log("On $sys->{sys} only $free KB for /opt, requirement is $require_space KB");
        $sys->push_error($msg);
    }
    return 1;
}


sub cli_prestart_config_questions {
    my ($prod) = @_;
    my ($mode,$ret,$vcs,$msg,$cpic);
    $cpic=Obj::cpic();
    $vcs = $prod->prod('VCS61');

    $ret = $prod->op_nic_hostname();
    if ($ret == 0 || $ret == 2) {
        $msg = Msg::new("NIC detecting error, please double check the enviroment.");
        $msg->error();
        $cpic->edr_completion();  
        return; 
	}
    $ret = $prod->init_cfg_val();

    return 1 unless($vcs->prestart_config_common_questions);

    $prod->config_cluster();
#    $prod->config_management_console;
    return;
}

# configure cluster id and heartbeat links
sub config_cluster {
    my $prod = shift;
    my ($ayn,$cfg,$clus_id,$clus_name,$done,$help,$msg,$rhbn,$summary,$vcs_prod);
    my ($autocfg_failed);
    $cfg = Obj::cfg();
    $vcs_prod = $prod->prod('VCS61');
    $cfg->{vcs_allowcomms} = 1;
    $done = 0;
    $autocfg_failed = 0;
    $cfg->{snas_clustername} ||= 'snascluster';
    $cfg->{vcs_clustername} = $cfg->{snas_clustername};
    $clus_name = $cfg->{snas_clustername};

    $rhbn = $vcs_prod->auto_config_llt();
    while (!$done) {
        $rhbn = $vcs_prod->hb_config_option('autocfg_failed') if ($autocfg_failed);
        next if (EDR::getmsgkey($rhbn, 'back'));
        $cfg->{vcs_clusterid} = int(rand(65535)) if (!defined($cfg->{vcs_clusterid}));
        $clus_id = $cfg->{vcs_clusterid};
        if ($vcs_prod->check_clusterid($clus_id,$rhbn)) {
            $clus_id = $vcs_prod->config_clusterid($clus_id,$rhbn);
        }
        $msg = $vcs_prod->display_config_info($clus_name,$clus_id,$rhbn);
        $summary = $msg;
        if ($cfg->{autocfgllt} && $vcs_prod->num_hbnics($rhbn) == 1 && $vcs_prod->num_lopri_hbnics($rhbn) == 0) {
            Msg::n();
            $msg = Msg::new("The following warning was discovered on the systems:");
            $msg->bold;
            Msg::n();
            $msg = Msg::new("Only one LLT private link is available");
            $msg->print();
        }
        Msg::n();
        $msg = Msg::new("Is this information correct?");
        $help =Msg::new("Verification of the input");
        $ayn = $msg->ayny($help);
        if ($ayn eq 'Y') {
            $done=1;
            $summary->add_summary(1);
        } else {
            $autocfg_failed = 1;
            delete($cfg->{autocfgllt});
        }
    }
    unless (Cfg::opt('responsefile')) {
        $cfg->{vcs_clusterid}=$clus_id;
        $vcs_prod->set_hb_nics($rhbn, CPIC::get('systems'));
        $cfg->{vcs_clustername} = $cfg->{snas_clustername};
    }
    delete($cfg->{autocfgllt});

    $prod->ssh_com_setup(CPIC::get('systems'));

    return;
}

sub config_management_console {
    my $prod = shift;
    my ($ayn,$cfg,$done,$msg,$msg_str,$netm,$mcnic_ref,$prefix,$vcs,$vip);
    $cfg = Obj::cfg();
    return '' if (Cfg::opt('responsefile'));
    $vcs = $prod->prod('VCS61');
    Msg::title();
    $msg = Msg::new("The following data is required to configure the Management Console:\n");
    $msg->bold;
    $msg = Msg::new("\tA public NIC used by each system in the cluster");
    $msg->print;
    $msg = Msg::new("\tA Virtual IP address and netmask");
    $msg->printn;
    do {
        $mcnic_ref = $vcs->ask_publicnic();
        next if (EDR::getmsgkey($mcnic_ref,'back'));
        $vip = $vcs->ask_vip('');
        next if (EDR::getmsgkey($vip,'back'));
        $netm = $vcs->ask_netmask($vip,$$mcnic_ref{${$cfg->{systems}}[0]});
        next if (EDR::getmsgkey($netm,'back'));
        Msg::title();
        if ( EDRu::ip_is_ipv6($vip)) {
            $prefix = Msg::new("Prefix");
        } else {
            $prefix = Msg::new("NetMask");
        }
        $msg = Msg::new("Management Console configuration verification:\n");
        $msg->bold;
        $msg_str = $vcs->display_csgnic($mcnic_ref);
        $msg = Msg::new("\tIP: $vip\n");
        $msg_str .= $msg->{msg};
        $msg = Msg::new("\t$prefix->{msg}: $netm\n");
        $msg_str .= $msg->{msg};
        Msg::print($msg_str);
        $msg = Msg::new("Is this information correct?");
        $ayn = $msg->ayny;
        $done = 1 if ($ayn eq 'Y');
    } while (!$done);
    $vcs->store_nic($mcnic_ref,'vcs_mc_nic');
    $cfg->{vcs_mc_vip} = $vip;
    $cfg->{vcs_mc_netmask} = $netm;
    return;
}

sub op_nic_hostname {
    my $prod = shift;
    my ($msg,$output,$done,$sub,$msg,$ayn,$cpic,$flag,$ayn);
    $flag = 1;

    $output = $prod->preconfig_precheck();
    if ($output == 0) {
        $done = 1;
        do {
            $msg = Msg::new("The NIC names have been configured, do you want to reconfigure them?");
            $ayn = $msg->aynn;
            return 1 if ($ayn eq 'N');  
            $done = 0 if($ayn eq 'Y');
        } while ($done);
    }

    if ($output == 2){
        Msg::new("$prod->{nicconf}->{udevconffile} does not found");
        $msg->error();
        return 2;
    }
    do {
        $output = $prod->cli_ask_start_value();
        if (!$output) {
            Msg::log("Errors in sub cli_ask_start_value with return value: $output");
            return 0;
        }

        $output = $prod->init_internal_val();

        $output = $prod->phase_detect_nic_ip();
        if ($output == 1) {
        }
        if ($output ==2) {
            Msg::log("Errors in sub phase_detect_nic_ip with return value: $output");
            return 0;
        }
        if ($output ==3) {
            next;
        }

        $output = $prod->display_info();
        next if (!$output);

        $output = $prod->buildup_config_info();

        $output = $prod->phase_config_nic_ip_hostname();
        if (!$output) {
            Msg::log("Errors in sub phase_config_nic_ip_hostname with return value: $output");
            return 0;
        }

        $output = $prod->phase_config_nic_ip_hostname_post();
        if (!$output) {
            return 0;
        }

        $output = $prod->write_nasinstallconf();

        #$output = $prod->handler_restart_network();

        $output = $prod->reboot_messages();
        if ($output) {
            $cpic=Obj::cpic();
            $cpic->edr_completion();
        }
        $flag = 0;
    } while ($flag);

    return 1;
}

sub init_cfg_val {
    my $prod = shift;
    my ($cfg,$clustername,$sys,$cpic,$console_ip);
    my (@private_devs,@public_devs,@vips,$netmask_list,$dev_list,$vip,$nvip,$netmask);
    my (@epws,@pris,@users,$epw,$user,$vcs_prod);
    $cpic = Obj::cpic();
    $sys = @{$cpic->{systems}}[0];
    $cfg = Obj::cfg();
    $vcs_prod = $prod->prod('VCS61');

    return 1 if (Cfg::opt('responsefile'));
    $clustername = $sys->cmd("_cmd_hostname 2>/dev/null");
    $clustername=~s/_(\d+)$//g;
    $cfg->{snas_clustername} = $clustername;

    # add users
    $vcs_prod->set_vcsencrypt();
    $user = 'admin';
    $epw = $vcs_prod->encrypt_password('password');
    push(@users,$user);
    push(@epws,$epw);
    push(@pris,'Administrators');
    $cfg->{vcs_username} = \@users;
    $cfg->{vcs_userpriv} = \@pris;
    $cfg->{vcs_userenpw} = \@epws;

    #FIXME: return for now.
    return 1;
    $console_ip = $sys->cmd("_cmd_cat $prod->{nicconf}->{consoleipfile} 2>/dev/null");
    chomp($console_ip);
    $console_ip = EDRu::despace($console_ip);
    $cfg->{snas_console_ip} = $console_ip;
    
    $dev_list = $sys->cmd("_cmd_cat $prod->{nicconf}->{publicdevicefile} 2>/dev/null"); 
    @public_devs = split(/\s+/, $dev_list);
    $cfg->{snas_public_nics} = \@public_devs;

    $dev_list = $sys->cmd("_cmd_cat $prod->{nicconf}->{privatedevicefile} 2>/dev/null");
    @private_devs = split(/\s+/, $dev_list);
    $cfg->{snas_private_nics} = \@private_devs;

    $netmask_list = $sys->cmd("_cmd_cat $prod->{nicconf}->{vipfile} 2>/dev/null");
    for my $line(split(/\n/, $netmask_list)) {
        ($vip, $netmask) = split(/\s+/, $line);
        push (@vips, $vip) if ($vip);
        $cfg->{snas_vip_netmask} ||= $netmask;
    };
    $cfg->{snas_vips} = \@vips;

    $nvip = $sys->cmd("_cmd_grep '^NVIPS' $prod->{nicconf}->{nasinstallconf} 2>/dev/null");
    if ( $nvip =~ /^NVIPS.*=\D*(\d+)/) {
        $cfg->{snas_nvips_per_nic} = $1;
    }

    return 1;
}

sub init_internal_val {
    my $prod = shift;
    my $cpic = Obj::cpic();
    for my $sys (@{$cpic->{systems}}) { 
        undef($sys->{oldhostname});
        undef($sys->{newhostname});
        undef(@{$sys->{publicnics}});
        undef(@{$sys->{privenics}});
        undef($sys->{npublicnics});
        undef($sys->{nprivenics});
        undef(@{$sys->{publicnics_new}});
        undef(@{$sys->{privenics_new}});
        undef(@{$sys->{publicip}});
        undef(@{$sys->{publicnetmask}});
        undef(@{$sys->{privateip}});
        undef(@{$sys->{privatenetmask}});
    }
    return 1;
}

sub phase_detect_nic_ip {
    my $prod = shift;
    my ($cfg,$edr,$mode,$phase,$phase_name, $phase_desc,$task_name,%task_params,$id,$task);

    $cfg = Obj::cfg();
    $edr=Obj::edr();
    $mode = Cfg::opt('serial');
    Cfg::set_opt('serial', 1) if ($mode eq '');

    $phase_name="Detecting PCI Devices, Network Devices and Available IPs";
    $phase_desc=Msg::new("Detecting Network Devices and Available IPs");
    $edr->{$prod->{fatal_error_key}} = 0;
    $edr->{$prod->{ip_error_key}} = 0;

    $phase= Phase->new($phase_name);
    $phase->set_description($phase_desc);
    $phase->set_fatal_error_key($prod->{fatal_error_key});
    $phase->initialize_tasks();

    $id=100;
    $task_name="product_checking_pci_exclusion_nics";
    %task_params=(
            'sequence_id' => $id,
            'description' => Msg::new("Detecting PCI Devices"),
            'description_sys' => Msg::new("Detecting PCI Devices on #{SYS}"),
            'if_per_system' => 1,
            'handler' => \&handler_pciexclusion_sys,
            'handler_object_arg' => $prod,
            );
    $task=Task->new($task_name, %task_params);
    $phase->add_task($task);

    $id+=100;
    $task_name="product_checking_nics";
    %task_params=(
            'sequence_id' => $id,
            'description' => Msg::new("Detecting Network Devices"),
            'description_sys' => Msg::new("Detecting Network Devices on #{SYS}"),
            'if_per_system' => 1,
            'handler' => \&handler_check_nics_sys,
            'handler_object_arg' => $prod,
            'post_handler' => \&post_handler_check_nics,
            'post_handler_object_arg' => $prod,
            );
    $task=Task->new($task_name, %task_params);
    $phase->add_task($task);

    $id+=100;
    $task_name="product_detect_ip";
    %task_params=(
            'sequence_id' => $id,
            'description' => Msg::new("Detecting Available IPs"),
            'description_sys' => Msg::new("Detecting Available IP on #{SYS}"),
            'if_per_system' => 0,
            'handler' => \&handler_check_ip,
            'handler_object_arg' => $prod,
            );
    $task=Task->new($task_name, %task_params);
    $phase->add_task($task);

    $phase->execute_tasks();

    Cfg::unset_opt('serial') if ($mode eq '');

    return $prod->phase_detect_nic_ip_post();
}

sub phase_detect_nic_ip_post {
    my $prod = shift;
    my ($msg,$cfg,$edr,$cpic,$backopt,$ayn,$help,@errorsysarr,$errorsys);
    $cfg = Obj::cfg();
    $edr=Obj::edr();
    $cpic = Obj::cpic();
    @errorsysarr=();
    $edr->{$prod->{fatal_error_key}} = 0;
    for my $sys (@{$cpic->{systems}}) {
        if ($sys->{$prod->{fatal_error_key}}) { 
            $edr->{$prod->{fatal_error_key}} = 1;
            push (@errorsysarr,$sys->{sys});
        }
    }

    Msg::n();
    $msg=Msg::new("Detecting PCI Devices, Network Devices and Available IPs completed successfully.");
    $msg->bold;

    if ($edr->{$prod->{fatal_error_key}}) {
        $errorsys = join(' ',@errorsysarr);
        Msg::n();
        $msg=Msg::new("Not enough network devices exist on $errorsys.");
        $msg->error();
        return 2;
    }

    if ($edr->{$prod->{ip_error_key}} == 2) {
        Msg::n();
        $msg = Msg::new("No enough available public IP starting with initial IP address. Do you want to continue?");
        $ayn = $msg->ayny;
        if ($ayn eq 'N') {
            return 2;
        }
        return 3;
    }

    if ($edr->{$prod->{ip_error_key}} == 3) {
        Msg::n();
        $msg = Msg::new("No enough available virtual IP starting with initial IP address. Do you want to continue?");
        $ayn = $msg->ayny;
        if ($ayn eq 'N') {
            return 2;
        }
        return 3;
    }

    return 1;
}

sub phase_config_nic_ip_hostname {
    my $prod = shift;
    my ($phase,$phase_name, $phase_desc,$task_name,%task_params,$id,$task);
    my $cfg = Obj::cfg();
#Cfg::set_opt('serial', 1);
    $phase_name="Redefining NIC, IP, hostname, DNS, gateway and user group";
    $phase_desc=Msg::new("Redefining NIC, IP, hostname, DNS, gateway and user group");

    $phase= Phase->new($phase_name);
    $phase->set_description($phase_desc);
    $phase->initialize_tasks();

    $id=100;
    $task_name="product_renaming_nics";
    %task_params=(
            'sequence_id' => $id,
            'description' => Msg::new("Configuring NICs"),
            'description_sys' => Msg::new("Configuring NICs on #{SYS}"),
            'if_per_system' => 1,
            'handler' => \&handler_config_nicnames_sys,
            'handler_object_arg' => $prod,
            );
    $task=Task->new($task_name, %task_params);
    $phase->add_task($task);

    $id+=100;
    $task_name="product_reassigning_ip";
    %task_params=(
            'sequence_id' => $id,
            'description' => Msg::new("Configuring IP"),
            'description_sys' => Msg::new("Configuring IP on #{SYS}"),
            'if_per_system' => 0,
            'handler' => \&handler_config_ip,
            'handler_object_arg' => $prod,
            );
    $task=Task->new($task_name, %task_params);
    $phase->add_task($task);

    $id+=100;
    $task_name="product_redefining_hostname";
    %task_params=(
            'sequence_id' => $id,
            'description' => Msg::new("Configuring Hostname"),
            'description_sys' => Msg::new("Configuring Hostname on #{SYS}"),
            'if_per_system' => 1,
            'handler' => \&handler_config_hostname_sys,
            'handler_object_arg' => $prod,
            );
    $task=Task->new($task_name, %task_params);
    $phase->add_task($task);

    $id+=100;
    $task_name="product_redefining_dns";
    %task_params=(
            'sequence_id' => $id,
            'description' => Msg::new("Configuring DNS"),
            'description_sys' => Msg::new("Configuring DNS on #{SYS}"),
            'if_per_system' => 1,
            'handler' => \&handler_config_dns_sys,
            'handler_object_arg' => $prod,
            );
    $task=Task->new($task_name, %task_params);
    $phase->add_task($task);

    $id+=100;
    $task_name="product_redefining_gateway";
    %task_params=(
            'sequence_id' => $id,
            'description' => Msg::new("Configuring Gateway"),
            'description_sys' => Msg::new("Configuring Gateway on #{SYS}"),
            'if_per_system' => 1,
            'handler' => \&handler_config_gateway_sys,
            'handler_object_arg' => $prod,
            );
    $task=Task->new($task_name, %task_params);
    $phase->add_task($task);

    $id+=100;
    $task_name="product_config_usergroup";
    %task_params=(
            'sequence_id' => $id,
            'description' => Msg::new("Configuring User and Group"),
            'description_sys' => Msg::new("Configuring User and Group on #{SYS}"),
            'if_per_system' => 1,
            'handler' => \&handler_users_groups_sys,
            'handler_object_arg' => $prod,
            );
    $task=Task->new($task_name, %task_params);
    $phase->add_task($task);

    $id+=100;
    $task_name="product_post_config_nicnames";
    %task_params=(
            'sequence_id' => $id,
            'description' => Msg::new("Performing postremove tasks"),
            'description_sys' => Msg::new("Performing postremove tasks on #{SYS}"),
            'if_per_system' => 1,
            'handler' => \&handler_postconfig_nicnames_sys,
            'handler_object_arg' => $prod,
            );
    $task=Task->new($task_name, %task_params);
    $phase->add_task($task);

    $phase->execute_tasks();

    return 1;
}

sub phase_config_nic_ip_hostname_post {
    my ($prod) = @_;
    my ($msg,$cfg);
    Msg::n();
    $msg=Msg::new("Redefining NIC, IP, hostname, DNS, gateway and user group completed successfully.");
    $msg->bold;

    $cfg = Obj::cfg();
    $cfg->{opt}{confignic}=1;
    return 1;
}

sub handler_check_nics_sys {
    my ($prod,$sys) = @_;
    my ($cfg,$padv,$edr,$oldhostname,$ethall,$nerreths,$nconneths,$ndisconneths,$nexclusioneths,@conneths,@disconneths,@erreths,@exclusioneths,$output,$pipstart,$gateway,$pnmaskstart,$ipproto,$src_ipv4,$src_ipv6,$src_mask,$src_prefix,@src_ipv4_arr,@src_ipv6_arr,@src_mask_arr,@src_prefix_arr,$scripts,$bits,$pipprefix,$ipaddress,$cmd,@src_prefixaddr,%src_ipv6_hash);
    $cfg = Obj::cfg();
    $padv=$sys->padv;
    $edr=Obj::edr();

    $ethall=$padv->get_all_nic_sys($sys);

#here use gateway from client
#$gateway = $padv->get_gateway_sys($sys);
    $gateway = $cfg->{snas_defgateway};
    $pipstart = $cfg->{snas_pipstart};
    $pipprefix = $cfg->{snas_pipprefix};
    $pnmaskstart = $cfg->{snas_pnmaskstart};
    $bits = EDRu::mask2cidr($pnmaskstart) if($prod->{netproto} eq $prod->{netprotoipv4});
    $oldhostname = $sys->cmd("_cmd_hostname 2>/dev/null");
    $sys->set_value('oldhostname',$oldhostname);

    if ($prod->{netproto} eq $prod->{netprotoipv6}) {
        $ipaddress = "$pipstart\/$pipprefix";
        $ipproto = "-6";
    } else {
        $ipaddress = "$pipstart\/$bits";
        $ipproto = "-4";
    }

    $nerreths=0;
    $nconneths=0;
    $ndisconneths=0;
    $nexclusioneths=0;
    %src_ipv6_hash={};
    @conneths=();
    @disconneths=();
    @erreths=();
    @src_ipv4_arr = ();
    @src_ipv6_arr = ();
    @src_mask_arr = ();
    @src_prefix_arr = ();
    @src_ipv6_arr = ();
    @exclusioneths = ();

$scripts = <<"_NIC_CONFIG"; 
/sbin/chkconfig --level 123456 NetworkManager off 2>/dev/null
/sbin/service NetworkManager stop 2>/dev/null
/sbin/service network restart
/sbin/sysctl -w net.ipv4.conf.all.rp_filter=0
/sbin/sysctl -w net.ipv4.conf.default.rp_filter=0
_NIC_CONFIG

    $output = $sys->cmd_script($scripts);

    for my $eth (@{$ethall}) {
        $src_ipv4 = $sys->cmd("_cmd_ifconfig | _cmd_grep $eth -A 3| _cmd_grep 'inet addr' | _cmd_awk '{print \$2}'|_cmd_awk -F: '{print \$2}'");
        $src_mask = $sys->cmd("_cmd_ifconfig | _cmd_grep $eth -A 2 | _cmd_grep 'Mask' | _cmd_awk '{print \$4}'| _cmd_awk -F: '{print \$2}'");
        $src_ipv6 = $sys->cmd("_cmd_ifconfig | _cmd_grep $eth -A 3| _cmd_grep 'inet6 addr' | _cmd_awk '{print \$3}'|_cmd_awk -F'/' '{print \$1}'");

        my @src_ipv6addr = split(/\n/,$src_ipv6);
        $src_ipv6_hash{$eth}=\@src_ipv6addr;

        $src_prefix = $sys->cmd("_cmd_ifconfig | _cmd_grep $eth -A 3| _cmd_grep 'inet6 addr' | _cmd_awk '{print \$3}'|_cmd_awk -F'/'  '{print \$2}'");
        @src_prefixaddr = split(/\n/,$src_prefix);
        $output = $sys->cmd("/sbin/sysctl -w net.ipv4.conf.$eth.rp_filter=0");

        if ($src_ipv4 eq '' || $src_mask eq '') {
            $src_ipv4 = "0.0.0.0";
            $src_mask = "0.0.0.0";
        }

        if ($src_ipv6addr[0] eq '' || $src_prefixaddr[0] eq '') {
            $src_ipv6 = "0:0:0:0:0:0:0:0";
            $src_prefix = 64;
        } else {
            $src_ipv6 = $src_ipv6addr[0];
            $src_prefix = $src_prefixaddr[0];
        }

        push (@src_ipv4_arr,$src_ipv4);
        push (@src_ipv6_arr,$src_ipv6);
        push (@src_mask_arr,$src_mask);
        push (@src_prefix_arr,$src_prefix);

        if ($src_ipv4 eq $sys->{sys} || $src_ipv4 eq $sys->{ip} || EDRu::inarr($sys->{sys},@src_ipv6addr) || EDRu::inarr($sys->{ip},@src_ipv6addr) || $prod->find_exclusion_nic_sys($sys,$eth)) {
            next;
        } else {
            $output = $sys->cmd("_cmd_ip addr flush $eth 2>/dev/null; _cmd_ifconfig $eth down 2>/dev/null");
        }
    }

    my $id = 0; 
    for my $eth (@{$ethall}){
        if ($prod->find_exclusion_nic_sys($sys,$eth)) {
            $id++;
            push (@exclusioneths, $eth); 
            $nexclusioneths++;
            next;
        }

        if (@src_ipv4_arr[$id] eq $sys->{sys} || @src_ipv6_arr[$id] eq $sys->{sys} ||$ndisconneths >= $prod->{max_priv_nic_num} || @src_ipv4_arr[$id] eq $sys->{ip} || EDRu::inarr($sys->{ip},@{$src_ipv6_hash{$eth}}) || EDRu::inarr($sys->{sys},@{$src_ipv6_hash{$eth}})) {
            $id++;
            $nconneths++;
            push (@conneths, $eth);
            next;
        }

        $id++;

$scripts = <<"_NIC_CONFIG"; 
/sbin/ip link set $eth up >/dev/null 2>&1 &
/sbin/ip addr flush $eth  >/dev/null 2>&1 &
/sbin/ip $ipproto addr add $ipaddress dev $eth >/dev/null 2>&1 &
_NIC_CONFIG

        $output = $sys->cmd_script($scripts);

        sleep 5;
        if(EDR::cmdexit()!=0) {
            $nerreths++;
            push (@erreths, $eth);
            Msg::log("set up $eth failed, set as error nics");
            next;
        }

        if ($prod->{netproto} eq $prod->{netprotoipv4}) {
            $output = $sys->cmd("_cmd_ping -i 2 -c 3 -I $eth $gateway 2>/dev/null");
        } else {
            $output = $sys->cmd("_cmd_ping6 -i 2 -c 3 -I $eth $gateway 2>/dev/null");
        }

        if (!EDR::cmdexit()) {
            $nconneths++;
            push (@conneths, $eth);
        } else {
            if ($ndisconneths < $prod->{max_priv_nic_num}) {
                $ndisconneths++;
                push (@disconneths, $eth);
            } else {
                $nconneths++;
                push (@conneths, $eth);
            }
        }
        
        $output = $sys->cmd("_cmd_ip addr flush $eth 2>/dev/null; _cmd_ifconfig $eth down 2>/dev/null");
    }

    for my $eth (@{$ethall}) {
        $src_ipv4 = shift  @src_ipv4_arr;
        $src_ipv6 = shift  @src_ipv6_arr;
        $src_mask = shift @src_mask_arr;
        $src_prefix = shift @src_prefix_arr;

        if ($src_ipv4 eq $sys->{sys} || $src_ipv4 eq $sys->{ip} || EDRu::inarr($sys->{sys},@{$src_ipv6_hash{$eth}}) || EDRu::inarr($sys->{ip},@{$src_ipv6_hash{$eth}}) || $prod->find_exclusion_nic_sys($sys,$eth)) {
            next;
        } else {
            if ($src_ipv4 ne "0.0.0.0" || $src_ipv6 ne "0:0:0:0:0:0:0:0") {
                $cmd = '';

                if ($src_ipv4 ne "0.0.0.0") {
                    $bits = EDRu::mask2cidr($src_mask);
                    $ipaddress = "$src_ipv4\/$bits";
                    $ipproto = "-4";
                    $cmd .= "/sbin/ip $ipproto addr add $ipaddress dev $eth  2>/dev/null;\n";
                }
                if ($src_ipv6 ne "0:0:0:0:0:0:0:0") {
                    $ipaddress = "$src_ipv6\/$src_prefix";
                    $ipproto = "-6";
                    $cmd .= "/sbin/ip $ipproto addr add $ipaddress dev $eth  2>/dev/null;\n";
                }

$scripts = <<"_NIC_CONFIG"; 
/sbin/ip link set $eth up  2>/dev/null
/sbin/ip addr flush $eth  2>/dev/null
$cmd
_NIC_CONFIG

                $output = $sys->cmd_script($scripts);
            } else {
                $output = $sys->cmd("_cmd_ifconfig $eth up 2>/dev/null");
                $output = $sys->cmd("_cmd_ip addr flush dev $eth 2>/dev/null");
            }
        }
    }

#if ($prod->ismasternode()) {

#    }

    $sys->set_value('publicnics','push',@conneths);
    $sys->set_value('privenics','push',@disconneths);
    $sys->set_value('exclusioneths','push',@exclusioneths);
    $sys->set_value('npublicnics',$nconneths);
    $sys->set_value('nprivenics',$ndisconneths);
    $sys->set_value('nexclusioneths',$nexclusioneths);

    if ($nconneths >= $prod->{minimum_pub_nic_num} && $ndisconneths >= $prod->{mininum_priv_nic_num}) {
        return 1;
    } else {
        $sys->set_value($prod->{fatal_error_key},1);
        return 0;
    }
}

sub handler_pciexclusion_sys {
    my ($prod, $sys) = @_;
    my ($cfg, $edr, $msg, @pciid, @exclusionnic, $counter, $output,@fieldarr,$index,$i);
    $cfg = Obj::cfg();
    $edr = Obj::edr();
    @exclusionnic = ();
    $counter = 0;

    if (!$cfg->{snas_pciexclusionid}) {
        $sys->set_value('pciexclusion','push',@exclusionnic);
        return 1;
    }

    @pciid = split(/\s+|[,;_]/,$cfg->{snas_pciexclusionid});

    for my $id (@pciid) {
        $output = $sys->cmd("_cmd_lshal | _cmd_grep 'linux.sysfs_path =.*/net/.*' | _cmd_grep -v 'virtual' |_cmd_awk -F \\' '{print \$2}'| _cmd_grep -iw $id"); 
        @fieldarr = split(/\//,$output);
        $index = @fieldarr;
        for ($i = $index -1; $i >= 0; $i--) {
            if(@fieldarr[$i] eq "net"){
                push (@exclusionnic, @fieldarr[$i+1]);
                $counter++;
                last;
            }
        }
    }

    $sys->set_value('pciexclusion','push',@exclusionnic);
    return 1;
}

sub find_exclusion_nic_sys {
    my ($prod,$sys,$nic) = @_;
    my ($match);
    my $cfg = Obj::cfg();
    $match = grep /^$nic/,@{$sys->{pciexclusion}};
    return 1 if ($match);
    return 0;
}

sub handler_config_gateway_sys {
    my ($prod, $sys) = @_;
    my ($cfg, $padv, $edr, $msg, $output);
    $cfg = Obj::cfg();
    $padv=$sys->padv;
    $output = $padv->configure_gateway_sys($sys,$cfg->{snas_defgateway});
    if ($output) {
    
    } else {
    
    }
    return 1;
}

sub handler_check_ip {
    my ($prod) = @_;
    my ($cfg, $edr, $output);
    my $cfg = Obj::cfg();
    my $edr = Obj::edr();
    return 1 if ($cfg->{opt}{bait});
    if ($prod->{netproto} eq $prod->{netprotoipv4}) {
        $output = $prod->precheck_ip_range($cfg->{snas_pipstart},$cfg->{snas_vipstart},$cfg->{snas_pnmaskstart},$cfg->{snas_vnmaskstart});   
    } else {
        $output = $prod->precheck_ip_range($cfg->{snas_pipstart},$cfg->{snas_vipstart},$cfg->{snas_pipprefix},$cfg->{snas_vipprefix});   
    }
    if ($output == 2) {
        Msg::log("public ip is out of range, install failed!");
        $edr->{$prod->{ip_error_key}} = 2;
        return 0;
    }
    if ($output == 3) {
        Msg::log("virtual ip is out of range, install failed!");
        $edr->{$prod->{ip_error_key}} = 3;
        return 0;
    }

    return 1;
}

sub handler_config_nicnames_sys {
    my ($prod,$sys) = @_;
    my ($cfg,$cpic,$output);
    $cfg = Obj::cfg();
    $cpic = Obj::cpic();
    $output = $prod->configure_nicnames($sys);
    if (!$output) {
        return 0;
    }
    return 1;
}

sub handler_postconfig_nicnames_sys {
    my ($prod,$sys) = @_;
    my ($cfg,$cpic,$fname,$ifcfgdir,$ifcfgfile,$cmd,$scripts,$output);
    
    $ifcfgdir = "/etc/sysconfig/network-scripts/ifconfig_bak"; 
    $ifcfgfile = "/etc/sysconfig/network-scripts/ifcfg-";
    $cfg = Obj::cfg();
    $cpic = Obj::cpic();
    $sys->mkdir($ifcfgdir);
    $cmd = '';

    for my $eth (@{$sys->{publicnics}}) {
        next if (($eth =~ /^pubeth\d+$/m) || ($eth =~ /^priveth\d+$/m));
        $fname = $ifcfgfile.$eth."*";
        $cmd .= "/bin/mv $fname $ifcfgdir\n";
    }
    for my $eth (@{$sys->{privenics}}) {
        next if (($eth =~ /^pubeth\d+$/m) || ($eth =~ /^priveth\d+$/m));
        $fname = $ifcfgfile.$eth."*";
        $cmd .= "/bin/mv $fname $ifcfgdir\n";
    }

$scripts = <<"_POST_CONFIG"; 
$cmd
_POST_CONFIG

    $output = $sys->cmd_script($scripts);
    return 1;
}

sub handler_config_hostname_sys {
    my ($prod,$sys) = @_;
    my $output;
    $output = $prod->configure_hostnames($sys);
    if (!$output) {
        return 0;
    }
    return 1;
}

sub handler_config_ip {
    my ($prod,$sys) = @_;
    my ($output);

    $output = $prod->configure_ip_nics();
    if (!$output) {
#TBD
#return 0;
    }
    for my $sys(@{CPIC::get('systems')}) {
        $prod->write_config_files_sys($sys);
    }
    return 1;
}

sub handler_config_dns_sys {
    my ($prod, $sys) = @_;
    my ($padv,$cfg,$cpic,$output,$padv);
    $cfg = Obj::cfg();
    $cpic = Obj::cpic();
    $padv=$sys->padv;
    $output = $padv->configure_dns_sys($sys,$cfg->{snas_dnsip},$cfg->{snas_dnsdomainname});
    if (!$output) {
        Msg::log("configure dns error");
#TBD
#return 0;
    }
    return 1;
}

sub handler_users_groups_sys {
    my ($prod,$sys) =@_;
    my ($output);
    $output = $prod->add_users_sys($sys);
    if ($output) {
        #TBD;
    }
    $output = $prod->add_groups_sys($sys);
    if ($output) {
        #TBD;
    }
    return 1;
}

sub post_handler_check_nics {
    my $prod = shift;
    my ($cpic,$edr,$cfg);
    $cpic = Obj::cpic();
    $cfg = Obj::cfg();
    for my $sys (@{$cpic->{systems}}) {
        if ($sys->{$prod->{fatal_error_key}}) { 
            $edr->{$prod->{fatal_error_key}} = 1;
        }
    }
    return 0 if($edr->{$prod->{fatal_error_key}});
    return 1;
}

sub preconfig_precheck{
    my $prod = shift;
    my ($cpic, $sys,$msg,$ayn,$flag);
    $cpic = Obj::cpic();
    $flag=0;
    for $sys (@{$cpic->{systems}}) {
        return 2 if (!$sys->exists($prod->{nicconf}->{udevconffile}));
        if ($prod->precheck_nicname($sys)) {
            $flag=1;
            last;
        }
    }

    if ($flag) {
        Msg::log("NIC is already renamed, skipping nic and host rename");
        return 0;
    }
    return 1;
}

sub precheck_nicname {
    my ($prod, $sys) = @_;
    my ($padv, $edr, $ethall);
    $padv=$sys->padv;
    $edr=Obj::edr();

    $ethall=$padv->get_all_nic_sys($sys);
    for my $eth (@{$ethall}) {
       if (($eth =~ /^pubeth\d+$/m) || ($eth =~ /^priveth\d+$/m)) {
           return 1;
       }
    }
    return 0;
}

sub cli_ask_start_value {
    my $prod = shift;
    my ($ayn,$padv,$cfg,$done,$msg,$msg_str,$help,$backopt,$netm,$mcnic_ref,$prefix,$vcs,$vip,$snas,$pipstart,$pnmaskstart,$vipstart,$vnmaskstart,$clustername,$def_gateway,$dnsip,$dnsdomainname,$pciexclusionid,$consoleip,$output,$hintpnmask,$hintvnmask,$rpn,$defnic,$nicl,$output,$nvips,$sepconsoleport,$pipprefix);
    $cfg = Obj::cfg();
    $backopt = '';

    my $cpic = Obj::cpic();
    my $sys = @{$cpic->{systems}}[0];
    $padv=$sys->padv;
    $rpn = $padv->publicnics_sys($sys);
    if ($#$rpn<0) {
        $msg = Msg::new("No active NIC devices have been discovered on $sys->{sys}");
        $msg->warning();
    } else {
        $nicl = join(' ',@$rpn);
    }
    $defnic = $$rpn[0];

    return 1 if (Cfg::opt('responsefile'));

    Msg::title();
    $msg = Msg::new("The following data is required to config the Storage NAS cluster:\n");
    $msg->bold;
    $msg = Msg::new("\tThe Storage NAS cluster name");
    $msg->printn;
    $msg = Msg::new("\tA initial public IP address and netmask");
    $msg->printn;
    $msg = Msg::new("\tA initial virtual IP address and netmask");
    $msg->printn;
    $msg = Msg::new("\tDefault Gateway IP address");
    $msg->printn;
    $msg = Msg::new("\tDNS Server IP address and Domain name");
    $msg->printn;
    $msg = Msg::new("\tConsole Virtual IP address");
    $msg->printn;
    $msg = Msg::new("\tPCI IDs for PCI exclusion");
    $msg->printn;
    $msg = Msg::new("System IP addresses will be defined sequentially starting with the initial address. System hostnames will be renamed as clustername_01, clustername_2, etc.");
    $msg->printn;

    do {
        $clustername = $prod->ask_clustername();
        $clustername = EDRu::despace($clustername);
        next if (EDR::getmsgkey($clustername,'back'));


        $pipstart = $prod->ask_pip_sys($sys);
        $pipstart = EDRu::despace($pipstart);
        next if (EDR::getmsgkey($pipstart,'back'));

        if (EDRu::ip_is_ipv6($pipstart)) {
            $prod->{netproto} = $prod->{netprotoipv6};
        } else {
            $prod->{netproto} = $prod->{netprotoipv4};
        }

        if ($prod->{netproto} eq $prod->{netprotoipv4}) {
            $hintpnmask = $sys->defaultnetmask($pipstart,$defnic);
            $pnmaskstart = $prod->ask_pnmask_sys($sys,$hintpnmask);
            $pnmaskstart = EDRu::despace($pnmaskstart);
            next if (EDR::getmsgkey($pnmaskstart,'back'));
        } else {
            $hintpnmask = $sys->defaultnetmask($pipstart,$defnic);
            $pipprefix = $prod->ask_pipprefix($hintpnmask);
            $pipprefix = EDRu::despace($pipprefix);
            next if (EDR::getmsgkey($pnmaskstart,'back'));
        }

        $vipstart = $prod->ask_vip_sys($sys);
        $vipstart = EDRu::despace($vipstart);
        next if (EDR::getmsgkey($vipstart,'back'));

        $nvips = $prod->ask_nvip(1);
        $nvips = EDRu::despace($nvips);
        next if (EDR::getmsgkey($nvips,'back'));

        $def_gateway = $prod->ask_default_gateway_sys($sys);
        $def_gateway = EDRu::despace($def_gateway);
        next if (EDR::getmsgkey($def_gateway,'back'));

        $dnsip = $prod->ask_dnsip_sys($sys);
        $dnsip = EDRu::despace($dnsip);
        next if (EDR::getmsgkey($dnsip,'back'));

        $dnsdomainname = $prod->ask_dnsdomainname_sys($sys);
        $dnsdomainname = EDRu::despace($dnsdomainname);
        next if (EDR::getmsgkey($dnsdomainname,'back'));

        $consoleip = $prod->ask_consoleip();
        $consoleip = EDRu::despace($consoleip);
        next if (EDR::getmsgkey($consoleip,'back'));

        $sepconsoleport = $prod->ask_sep_console_port();
        $sepconsoleport = EDRu::despace($sepconsoleport);
        next if (EDR::getmsgkey($sepconsoleport,'back'));

        $output = $prod->ask_pciexclusionid_option(); 
        if ($output) {
            $pciexclusionid = $prod->ask_pciexclusionid();
            $pciexclusionid = EDRu::despace($pciexclusionid);
            next if (EDR::getmsgkey($pciexclusionid,'back'));
        }

        Msg::n();
        $msg = Msg::new("Is this information correct?");
        $ayn = $msg->ayny;
        $done = 1 if ($ayn eq 'Y');
    } while (!$done);

    $cfg->{snas_pipstart} = $pipstart;
    $cfg->{snas_pnmaskstart} = $pnmaskstart;
    $cfg->{snas_clustername} = $clustername;
    $cfg->{snas_vipstart} = $vipstart;
    $cfg->{snas_vnmaskstart} = $pnmaskstart;
    $cfg->{snas_defgateway} = $def_gateway;
    $cfg->{snas_dnsip} = $dnsip;
    $cfg->{snas_dnsdomainname} = $dnsdomainname;
    $cfg->{snas_consoleip} = $consoleip;
    $cfg->{snas_pciexclusionid} = $pciexclusionid;
    $cfg->{snas_nvip} = $nvips;
    $cfg->{snas_pipprefix} = $pipprefix;
    $cfg->{snas_sepconsoleport} = $sepconsoleport;
    $cfg->{snas_vipprefix} = $pipprefix;

    return 1;
}

sub display_info {
    my ($prod) = @_;
    my ($output) ;

    $output = $prod->display_initial_value();
    if ($output) {
        Msg::log("display ip pool info success!");
        return 1;
    } else {
        Msg::log("display ip pool info failed!");
        return 0;
    }

}

sub display_initial_value {
    my ($prod) = @_;
    my (@titles,$cfg,$cpic,@pip,@vip,@nmask,@vnmask,@pubeths,@priveths,$pubprefix,$index,$msg,$oldhostname,$newhostname,$hostnameid,$id,$nicid,$ayn,$done,$privprefix,$i,$pid,$vid);

    $cfg = Obj::cfg();
    $cpic = Obj::cpic();

    $index=0;
    $pubprefix = "pubeth";
    $privprefix = "priveth";
    @pip = @{$cfg->{snas_ip_pool}->{public}};
    @vip = @{$cfg->{snas_ip_pool}->{private}};
    @nmask = @{$cfg->{snas_nmask_pool}->{public}};
    @vnmask = @{$cfg->{snas_nmask_pool}->{private}};
    $cfg->{publiciparr} = \@pip;
    $cfg->{virtualiparr} = \@vip;
    $cfg->{publicnetmaskarr} =  \@nmask;
    $cfg->{virtualnetmaskarr} = \@vnmask;

    return 1 if (Cfg::opt('responsefile')); 

    Msg::title();
    $msg = Msg::new("Configuration Checklist:");
    $msg->bold;

    Msg::n();

    $hostnameid = 1;
    $index = 0;
    $nicid =0;
    for my $sys (@{$cpic->{systems}}) {


        printf "%-20s%-20s\n","System:",$sys->{sys};

        $oldhostname = $sys->{oldhostname};

        if ($hostnameid < 10) {
            $newhostname = $cfg->{snas_clustername}."_0".$hostnameid;
        } else {
            $newhostname = $cfg->{snas_clustername}."_".$hostnameid;
        }
        printf "\t%-20s%-20s\n","Hostname",$oldhostname;
        printf "\t%-20s%-20s\n","new Hostname",$newhostname;
        $hostnameid++;

        printf "\t%-20s%-20s\n","Gateway IP:",$cfg->{snas_defgateway};
        printf "\t%-20s%-20s\n","DNS IP:",$cfg->{snas_dnsip};
        printf "\t%-20s%-20s\n","Domain Name:",$cfg->{snas_dnsdomainname};
        Msg::n();

        $pid=0;
        $vid=0;
        @pubeths =  @{$sys->{publicnics}};
        for my $eth (@pubeths) {
            printf "\t%-20s%-20s\n","NIC name:",$eth;
            printf "\t%-20s%-20s\n","new NIC name:",$pubprefix.$pid;
            printf "\t%-20s%-20s\n","Physical IP:",@pip[$index++];
            printf "\t%-20s","Virtual IP:";

            for ($i = 0 ; $i < $cfg->{snas_nvip};) {
                if ($i != 0) {

                    printf "\n\t%-20s"," ";
                }
                printf "%-20s",@vip[(($nicid * $cfg->{snas_nvip}) + ($i++))];
            }
            $nicid++;
            $pid++;
            Msg::n();
            Msg::n();
        }

        @priveths = @{$sys->{privenics}};
        for my $eth (@priveths) {
            printf "\t%-20s%-20s\n","NIC name:",$eth;
            printf "\t%-20s%-20s\n","new NIC name:",$privprefix.$vid;
            Msg::n();
            $vid++;
        }
    }

    Msg::n();
    $msg = Msg::new("Is this information correct?");
    $ayn = $msg->ayny;
    return 1 if ($ayn eq 'Y');

    return 0;
}

sub precheck_ip_range {
    my ($prod,$pipstart,$vipstart,$pnmaskstart,$vnmaskstart) = @_;
    my ($cfg,$sys,$padv,$npublicnicall,$nprivatenicall,$output,$id,$inuse,$vipbit,$vipstartbit,$pipbit,$pipstartbit,@nip);
    my $cfg = Obj::cfg();
    my $cpic = Obj::cpic();
    $npublicnicall = 0;
    for $sys (@{$cpic->{systems}}) {
        $npublicnicall  +=  $sys->{npublicnics};
    }

    my $pip = $pipstart;
    my $vip = $vipstart;
    $sys = @{$cpic->{systems}}[0];
    $padv  = $sys->padv;
    $id = 0;
    $prod->truncate_ip_pool();
    do {
        $output = $prod->check_ip_available($sys,$pip); 
        if (!$output) {
            Msg::log("$pip is invalid!");
            $pip = $prod->get_next_ip($pip,1);
        }
        else {
            $prod->set_ip_to_ppool($pip);
            $prod->set_nmask_to_ppool($pnmaskstart);
            $pip = $prod->get_next_ip($pip,1);
            $id++;
        }

        if ($prod->{netproto} eq $prod->{netprotoipv4}) {
            @nip = split(/\./,$pip);
            if ($nip[3] >= 255) {
                Msg::log("$pip is invalid! Out of range!");
                return 2;
            }
        } else {
            $pipbit = EDRu::ipv6bit($pip,$pnmaskstart);
            $pipstartbit = EDRu::ipv6bit($pipstart,$pnmaskstart);
            if ($pipbit != $pipstartbit || $pipbit ==2 || $pipstartbit==2) {
                Msg::log("$pip is invalid! Out of range!");
                return 2;
            }
        }
    } while ($id < $npublicnicall);

    $id = 0;
    do {
        $output = $prod->check_ip_available($sys,$vip); 
        if (!$output) {
            Msg::log("$vip is invalid!");
            $vip = $prod->get_next_ip($vip,1);
        }
        else {
            $inuse = $prod->dedup_vip($vip);
            if (!$inuse) {
                $prod->set_ip_to_vpool($vip);
                $prod->set_nmask_to_vpool($vnmaskstart);
                $vip = $prod->get_next_ip($vip,1);
                $id++;
            } else {
                Msg::log("$vip is inuse!");
                $vip = $prod->get_next_ip($vip,1);
            }
        }

        if ($prod->{netproto} eq $prod->{netprotoipv4}) {
            @nip = split(/\./,$vip);
            if ($nip[3] >= 255) {
                Msg::log("$vip is invalid! Out of range!");
                return 3;
            }
        } else {
            $vipbit = EDRu::ipv6bit($vip,$vnmaskstart);
            $vipstartbit = EDRu::ipv6bit($vipstart,$vnmaskstart);
            if ($vipbit != $vipstartbit || $vipbit ==2 || $vipstartbit==2) {
                Msg::log("$vip is invalid! Out of range!");
                return 3;
            }
        }
    } while ($id < $npublicnicall*$cfg->{snas_nvip});

    return 1;
}

sub get_hint_ip {
    my ($prod,$sys,$ip) = @_;
    my ($i,$hint,$output,$flag);
    my $padv=$sys->padv;
    $hint = $ip;
    $flag = 0;
    for ($i = 0; $i < 6; $i++) { 
        $hint = $prod->get_next_ip($hint,1);
        $output = $prod->check_ip_available($sys,$hint);
        if (!$output) { 
            $flag = 1;
            next;
        } else {
            $flag = 0;
            last;
        }
    }
    if ($flag == 0) {
        return $hint;
    } else {
        return "0.0.0.0";
    }
}

sub check_pciid_available {
    my ($prod, $pciidstr) = @_;
    my (@pciid,$output);
    @pciid = split(/\s+|[,;_]/,$pciidstr);
    for my $id (@pciid) {
       $output = $id =~ /^[\da-z]+:[\da-z]+:[\da-z]+\.[\da-z]+$/;
       return 0 if (!$output);
    }
    return 1;
}

sub check_ip_available {
    my ($prod,$sys,$ip) = @_;
    my ($ipversion,$ipversion1,$ipversion2,$id,$padv,$ret1,$ret2);
    my $localsys=EDR::get('localsys');
    $id = 0;
    $padv=$sys->padv;
    $ipversion1 = EDRu::ip_is_ipv4($ip);
    $ipversion2 = EDRu::ip_is_ipv6($ip);

    if (!$ipversion1 && !$ipversion2) {
        return 0;
    }
    if ($ipversion1 == 1) {
        $ipversion = 4;
    } else {
        $ipversion = 6;
    }
    my $ret1 = EDRu::ip_iptype($ip,$ipversion);
    my $ret2 = $localsys->padv->ping($ip);
    if ($ret1 eq 'PUBLIC' && $ret2 eq 'noping') {
        return 1;
    }
    return 0;
}

sub dedup_vip {
    my ($prod, $vip) = @_;
    my ($cfg, $matchpip,$matchvip);
    $cfg= Obj::cfg();
    $matchpip = grep /^$vip/,@{$cfg->{snas_ip_pool}->{public}};
    $matchvip = grep /^$vip/,@{$cfg->{snas_ip_pool}->{private}};
    if ($matchpip || $matchvip) {
        return 1;
    }
    return 0;
}

sub buildup_config_info {
    my ($prod) = @_;
    my ($hostnameid,$cpic,$oldhostname,$cfg,$pubprefix,$privprefix,@conneths,$nconneths,@disconneths,$nconneths_new,$ndisconneths_new,$nconneths,$ndisconneths,$pubid,$privid,$pip,$pmask,$vip,$vmask,$i);

    $cfg= Obj::cfg();
    $cpic = Obj::cpic();
    $hostnameid = 1;

    for my $sys (@{$cpic->{systems}}) {
        $oldhostname = $sys->{oldhostname};
        if ($hostnameid < 10) {
            $sys->{newhostname} = $cfg->{snas_clustername}."_0".$hostnameid;
        } else {
            $sys->{newhostname} = $cfg->{snas_clustername}."_".$hostnameid;
        }
        $hostnameid++;
    }

    $pubprefix = "pubeth";
    $privprefix = "priveth";
    $nconneths_new = 0;
    $ndisconneths_new = 0;

    for my $sys (@{$cpic->{systems}}) {
        my @conneths_new = ();
        my @disconneths_new = ();
        $nconneths = $sys->{npublicnics};
        $ndisconneths = $sys->{nprivenics};
        if ( $nconneths == 0) {
            @conneths = (); 
        }
        else {
            @conneths =  @{$sys->{publicnics}};
        }

        if ( $ndisconneths == 0) {
            @disconneths = (); 
        }
        else {
            @disconneths = @{$sys->{privenics}}; 
        }

        $pubid = 0;
        for my $eth (@conneths) {
            push (@conneths_new,$pubprefix.$pubid);
            $pubid++;
        }

        $privid = 0;
        for my $eth (@disconneths) {
            push (@disconneths_new,$privprefix.$privid);
            $privid++;
        }

        $sys->set_value('publicnics_new','push', @conneths_new);
        $sys->set_value('npublicnics_new', $pubid);
        $sys->set_value('privenics_new','push', @disconneths_new);
        $sys->set_value('nprivenics_new', $privid);
    }

    for my $sys (@{$cpic->{systems}}) {
        my @pubip_arr=();
        my @pubnmask_arr=();
        my @privip_arr=();
        my @privnmask_arr=();

        for my $eth (@{$sys->{publicnics_new}}) {
            $pip = $prod->get_ip_from_ppool();
            $pmask = $prod->get_nmask_from_ppool();
            push (@pubip_arr,$pip);
            push (@pubnmask_arr,$pmask);

            for ($i = 0 ; $i < $cfg->{snas_nvip}; $i++) {
                $vip = $prod->get_ip_from_vpool();
                $vmask = $prod->get_nmask_from_vpool();
                push (@privip_arr,$vip);
                push (@privnmask_arr,$vmask);
            }
        }

        $sys->set_value('publicip','push', @pubip_arr);
        $sys->set_value('publicnetmask','push', @pubnmask_arr);
        $sys->set_value('privateip','push', @privip_arr);
        $sys->set_value('privatenetmask','push', @privnmask_arr);
    }
    return 1;
}

sub configure_nicnames {
    my ($prod,$sys) = @_;
    my ($padv,$pubprefix,$priprefix,$gateway,$nconneths,$ndisconneths,@conneths,@disconneths,$nconneths_new,$ndisconneths_new,@conneths_new,@disconneths_new,$output,$id,$output,$couldrestart,$index);

    $padv=$sys->padv;
    my $cfg = Obj::cfg();
#$gateway = $padv->get_gateway_sys($sys); #may be sth err!
    $gateway = $cfg->{snas_defgateway};
    $couldrestart = 1;

    @conneths = @{$sys->{publicnics}};
    @disconneths = @{$sys->{privenics}};
    @conneths_new = @{$sys->{publicnics_new}};
    @disconneths_new = @{$sys->{privenics_new}};

    for ($index = 0; $index < @conneths; $index++) {
        $output = $padv->configure_nicname_sys($sys,@conneths[$index],@conneths_new[$index]);
        $couldrestart &= $output;
    }

    for ($index = 0; $index < @disconneths; $index++) {
        $output = $padv->configure_nicname_sys($sys,@disconneths[$index],@disconneths_new[$index]);
        $couldrestart &= $output;
    }

    return 1 if ($couldrestart);
    return 0;
}

sub configure_hostnames {
    my ($prod,$sys) = @_;
    my ($output,$padv);
    $padv=$sys->padv;
    $output = $padv->configure_hostname_sys($sys,$sys->{newhostname});
    if (!$output) {
        Msg::log("$sys config hostname failed!");
        return 0;
    } else {
        return 1;
    }
}

sub configure_ip_nics {
    my ($prod) = @_;
    my ($cfg);
    my (@pubeths,@priveths,@pubethsnew,@privethsnew,$pip,$pmask,$vip,$vmask,$output,$res,$index,$nic,$nicnew,$i);
    my (@iphostsarr,@freepriviparr,@physicaliparr,@privatedevicearr,@privateiparr,@publicdevicearr,@pubip_arr,@viparr,@vip_arr,@vipdevicearr);
    my ($newsysname,$padv,$sys,$syslist);
    $cfg = Obj::cfg();

    $syslist = CPIC::get('systems');
    $sys = ${$syslist}[0];
    $padv=$sys->padv;
    @privethsnew =  @{$sys->{privenics_new}};
    @pubethsnew =  @{$sys->{publicnics_new}};

#$pmask = ${$sys->{publicnetmask}}[0];
#$vmask = ${$sys->{privatenetmask}}[0];

    if ($prod->{netproto} eq $prod->{netprotoipv4}) {
        $pmask = $cfg->{snas_pnmaskstart};
        $vmask = $pmask;
       } else {
        $pmask = $cfg->{snas_pipprefix};
        $vmask = $pmask;
    }

    @physicaliparr = ();
    @publicdevicearr = ();
    @privatedevicearr = ();
    @privateiparr = ();
    @viparr = ();
    @vipdevicearr = ();
    $res = 1;
    $index = 0;
    @freepriviparr = @{$prod->{privateiparr}};

    for my $system (@$syslist) {
        $newsysname = $system->{newhostname};
        @pubip_arr = @{$system->{publicip}};
        @vip_arr = @{$system->{privateip}};
        $system->set_value('hostip',$pubip_arr[0]);
        @pubeths =  @{$system->{publicnics}};
        @priveths =  @{$system->{privenics}};
        for ($index = 0; $index < @pubip_arr; $index++) {
            $pip = $pubip_arr[$index];
            $nic = $pubeths[$index];
            $nicnew = $pubethsnew[$index];
            # rename NIC and configure public physical IP on each system
            $output = $padv->configure_ip_sys($system,$nic,$nicnew,$pip,$pmask,$prod->{netproto});
            $res &= $output;
            push (@physicaliparr, "$pip $pmask $newsysname $nicnew");

            for ($i = $index*$cfg->{snas_nvip} ; $i < ($index+1)*$cfg->{snas_nvip}; $i++) {
                $vip = $vip_arr[$i];
                push (@viparr, "$vip $vmask");
            }
        }
# rename NIC and configure private IP on priveth0 of each system
        my $privip = shift @freepriviparr;
        $output = $padv->configure_ip_sys($system,$priveths[0],$privethsnew[0],$privip,$prod->{privateipnetmask},$prod->{netprotoipv4});
        $res &= $output;
        push (@privateiparr, "$privip $prod->{privateipnetmask} $newsysname $privethsnew[0]");
        push (@iphostsarr, "$privip\t$newsysname");
    }
    # generate private ip array of all the systems 
    for my $privip (@freepriviparr) {
        push (@privateiparr, "$privip $prod->{privateipnetmask}");
    }

    @publicdevicearr = @pubethsnew;
    @vipdevicearr = @pubethsnew;
    @privatedevicearr = @privethsnew;

    for my $system (@$syslist) {
        $system->set_value('physicaliparr','push', @physicaliparr);
        $system->set_value('publicdevicearr','push', @publicdevicearr);
        $system->set_value('privatedevicearr','push', @privatedevicearr);
        $system->set_value('privateiparr','push', @privateiparr);
        $system->set_value('viparr','push', @viparr);
        $system->set_value('vipdevicearr','push', @vipdevicearr);
        $system->set_value('iphostsarr','push', @iphostsarr);
    }

    return $res;
}

sub write_config_files_sys {
    my ($prod,$sys) = @_;
    my $cfg = Obj::cfg();
    my @physicaliparr =@{$sys->{physicaliparr}};
    my @publicdevicearr = @{$sys->{publicdevicearr}};
    my @privatedevicearr = @{$sys->{privatedevicearr}};
    my @privateiparr = @{$sys->{privateiparr}};
    my @viparr = @{$sys->{viparr}};
    my @vipdevicearr = @{$sys->{vipdevicearr}};
    my @iphostsarr = @{$sys->{iphostsarr}};

    $sys->mkdir($prod->{nicconf}->{filepath});
    $prod->set_physicalipfile_sys($sys,@physicaliparr);
    $prod->set_publicdevicefile_sys($sys,@publicdevicearr);
    $prod->set_privatedevicefile_sys($sys,@privatedevicearr);
    $prod->set_privateipfile_sys($sys,@privateiparr);
    $prod->set_vipfile_sys($sys,@viparr);
    $prod->set_vipdevicefile_sys($sys,@vipdevicearr);
    $prod->set_consoleipfile_sys($sys);
    $prod->set_consoledevfile_sys($sys);
    $prod->set_globalroutesfile_sys($sys);
    $prod->update_hosts_file_sys($sys,@iphostsarr);

#$prod->write_nasinstallconf_sys($sys);
    return 1;
}

sub reboot_messages {
    my ($prod) = @_;
    my ($reboot_msg,$msg,$cpic,$padv,@reboot_systems,@reboot_systems_ip,$reboot_systems_str,$reboot_systems_ip_str);

    $cpic=Obj::cpic();
    $padv=Obj::padv($cpic->{padv});
    @reboot_systems=();
    @reboot_systems_ip=();
    for my $sys (@{$cpic->{systems}}) {
        push (@reboot_systems,$sys->{sys}); 
        push (@reboot_systems_ip,@{$sys->{publicip}}[0]);
    }
    $reboot_systems_str = join(' ',@reboot_systems);
    $reboot_systems_ip_str = join(' ',@reboot_systems_ip);
    $msg=Msg::new("It is strongly recommended to reboot the following systems:\n\t$reboot_systems_str\n\nExecute '$padv->{cmd}{shutdown}' to properly restart your systems");
    $reboot_msg.=$msg->{msg};
    my $script=EDR::get('script');
    $msg=Msg::new("\n\nAfter reboot, run the '$script -configure' to continue configuring the following systems:\n\t$reboot_systems_ip_str");
    $reboot_msg.=$msg->{msg};
    Msg::display_bold($reboot_msg);
    return 1;
}

sub add_groups_sys {
    my ($prod, $sys)=@_;
    $sys->cmd("_cmd_groupadd -g 1001 master");
    $sys->cmd("_cmd_groupadd -g 1002 sysadmin");
    $sys->cmd("_cmd_groupadd -g 1003 stoadmin");
    $sys->cmd("_cmd_groupadd -g 1004 sysstoadmin");
    $sys->cmd("_cmd_groupadd -g 1005 Xmaster");
    return 1;
}

sub add_users_sys {
    my ($prod,$sys)=@_;
    $sys->mkdir($prod->{clish}->{clishhomepath});
    $sys->mkdir($prod->{clish}->{supporthomepath});
    $sys->cmd("_cmd_userdel -r master");
    $sys->cmd("_cmd_useradd master -d $prod->{clish}->{clishhomepath} -s $prod->{clish}->{clishpath} -g Xmaster -G master,root,sysadmin,stoadmin,sysstoadmin");
    $sys->cmd("_cmd_usermod -o -u 0 master");
    $sys->cmd("_cmd_chown -R master:Xmaster $prod->{clish}->{clishhomepath}");
    $sys->cmd("_cmd_useradd support -d $prod->{clish}->{supporthomepath} -s $prod->{clish}->{bashpath} -g root");
    $sys->cmd("_cmd_usermod -o -u 0 support");
    return 1;
}

sub build_key_path {
    my ($prod) = @_;
    my (%kvs,$cfg,$cpic);

    %kvs = {};
    $cfg = Obj::cfg();
    $cpic = Obj::cpic();

    $kvs{"MODE"} = $prod->{mode}->{master};
    $kvs{"LICENSE_TYPE"}="ENTERPRISE";
    $kvs{"LICENSE"}="8RZG-3FSI-RVFF-8OTJ-ZLGO-WZP8-O63P-P";
    $kvs{"GATEWAYNAME"}=$cfg->{snas_clustername};
    $kvs{"NNODES"}=@{$cpic->{systems}};
    $kvs{"SINGLENODE"}="no";
    $kvs{"SEPCONSOLE"}=$cfg->{snas_sepconsoleport};
    $kvs{"NVIPS"}=$cfg->{snas_nvip};
    $kvs{"PCIEXCLUSIONID"}=$cfg->{snas_pciexclusionid};
    $kvs{"PIPSTART"}=$cfg->{snas_pipstart};
    $kvs{"PIPMASK"}=$cfg->{snas_pnmaskstart};
    $kvs{"VIPMASK"}=$cfg->{snas_vnmaskstart};
    $kvs{"VIPSTART"}=$cfg->{snas_vipstart};
    $kvs{"CONSIP"}=$cfg->{snas_consoleip};
    $kvs{"NTPSERVER"}="ntp.symantec.com";
    $kvs{"DNS"}=$cfg->{snas_dnsip};
    $kvs{"DOMAINNAME"}=$cfg->{snas_dnsdomainname};
    $kvs{"GATEWAY"}=$cfg->{snas_defgateway};
    $kvs{"NPORTS"}="4";
    $kvs{"PUBBONDEVICEID"}='';
    $kvs{"PUB_BOND_MODE"}="1";
    $kvs{"NLMMASTERIP"}="172.16.0.2";
    $kvs{"DHCP_RANGE_START"}="172.16.0.20";
    $kvs{"DHCP_RANGE_END"}="172.16.0.35";
    $kvs{"PRIVATE_NET_SUBNET"}="172.16.0.0";
    $kvs{"PRIVATE_NET_NETMASK"}="255.255.255.0";
    $kvs{"NETPROTO"}=$prod->{netproto};

    return \%kvs;
}

sub build_nasinstallconf_sys {
    my ($prod,$sys) = @_;
    my ($padv,@items,$confhash,$macs,$mac);

    $padv=$sys->padv;
    $confhash = $prod->build_key_path();
    $macs = $prod->get_all_nics_mac_sys($sys);
    $mac = join(',',@{$macs});
    if ($sys->system1) {
        $confhash->{"MODE"}=$prod->{mode}->{master};
        $confhash->{"INSTSERVVIP"}="172.16.0.1";
        $confhash->{"NPORTS"}=@{$sys->{publicdevicearr}}+@{$sys->{privatedevicearr}};
    } else {
        $confhash->{"MODE"}=$prod->{mode}->{slave};
        $confhash->{"NPORTS"}=@{$sys->{publicdevicearr}}+@{$sys->{privatedevicearr}};
        $confhash->{"SERVERIP"}="172.16.0.1";
        $confhash->{"MACS"}=$mac;
        $confhash->{"PRIVATE0_MAC"}= $padv->get_mac_by_nic_sys($sys,@{$sys->{privenics}}[0]);
    }

    foreach my $key(sort (keys %{$confhash})) {
        next unless ($confhash->{$key}); 
        push (@items,$key);
        push (@items,$confhash->{$key});
    }

    $sys->set_value('nasinstallconf','push', @items);
    return 1;
}

sub write_nasinstallconf {
    my ($prod) = @_;
    my ($output,$cpic);
    $cpic = Obj::cpic();
    for my $sys (@{$cpic->{systems}}) {
        $output = $prod->write_nasinstallconf_sys($sys);
    }
}

sub write_nasinstallconf_sys{
    my ($prod,$sys) = @_;
    my ($file,$filelocpath,$obj,$edr,$cpic,$tmpdir);
    
    $edr=Obj::edr();
    $tmpdir=EDR::tmpdir();

    $filelocpath = "$tmpdir/nasinstall.conf"; 
    $file = $prod->{nicconf}->{nasinstallconf};

    $sys->mkdir("$prod->{nicconf}->{nodefilepath}");
    $sys->cmd("_cmd_touch $prod->{nicconf}->{nasinstallconf}");
    $sys->cmd("_cmd_cat /dev/null > $prod->{nicconf}->{nasinstallconf}");

    $prod->build_nasinstallconf_sys($sys);

    $prod->set_default_values($filelocpath,@{$sys->{nasinstallconf}});
    if ($sys->{islocal}) {
        $sys->copyfile($filelocpath,$file);
    } else {
        $edr->localsys->copy_to_sys($sys,$filelocpath,$file);
    }
    return 1;
}

sub get_all_nics_mac_sys {
    my ($prod,$sys) = @_;
    my ($padv,$output,@macs,$cpic);

    $cpic=Obj::cpic();
    $padv=$sys->padv;
    @macs=();

    my @publicdevicearr = @{$sys->{publicnics}};
    my @privatedevicearr = @{$sys->{privenics}};
    for my $nic (@publicdevicearr) {
        $output = $padv->get_mac_by_nic_sys($sys,$nic);
        push (@macs, $output);
    }
    for my $nic (@privatedevicearr) {
        $output = $padv->get_mac_by_nic_sys($sys,$nic);
        push (@macs, $output); 
    }
    return \@macs;
}

sub set_physicalipfile_sys {
    my ($prod,$sys,@arr) = @_;
    my $content;
    for my $line (@arr) {
        $content .= "$line\n";
    }
    $sys->writefile($content,$prod->{nicconf}->{physicalipfile});
    return 1;
}

sub set_publicdevicefile_sys {
    my ($prod,$sys,@arr) = @_;
    my $line = join(' ',@arr);
    $line .= "\n";
    $sys->writefile($line,$prod->{nicconf}->{publicdevicefile});
    return 1;
}

sub set_vipdevicefile_sys  {
    my ($prod,$sys,@arr) = @_;
    my $line = join(' ',@arr);
    $line .= "\n";
    $sys->writefile($line,$prod->{nicconf}->{vipdevicefile});
    return 1;
}

sub set_privatedevicefile_sys  {
    my ($prod,$sys,@arr) = @_;
    my $line = $arr[0];
    $line .= "\n";
    $sys->writefile($line,$prod->{nicconf}->{privatedevicefile});
    return 1;
}

sub set_privateipfile_sys  {
    my ($prod,$sys,@arr) = @_;
    my $content;
    for my $line (@arr) {
        $content .= "$line\n";
    }
    $sys->writefile($content,$prod->{nicconf}->{privateipfile});
    return 1;
}

sub set_vipfile_sys  {
    my ($prod,$sys,@arr) = @_;
    my $content;

    for my $line (@arr) {
        $content .= "$line\n";
    }
    $sys->writefile($content,$prod->{nicconf}->{vipfile});

    return 1;
}

sub set_consoleipfile_sys  {
    my ($prod,$sys) = @_;
    my ($cfg, $content);
    $cfg = Obj::cfg();

    $content = "$cfg->{snas_consoleip} ${$sys->{privatenetmask}}[0]\n";
    $sys->writefile($content,$prod->{nicconf}->{consoleipfile});

    return 1;
}

sub set_consoledevfile_sys  {
    my ($prod,$sys) = @_;
    my $content = "${$sys->{publicdevicearr}}[0]\n";
    $sys->writefile($content,$prod->{nicconf}->{consoledevfile});
    return 1;
}

sub set_globalroutesfile_sys {
    my ($prod,$sys) = @_;
    my ($content,$syslist,$id,$hostname,$cfg);
    $cfg= Obj::cfg();
    $syslist = CPIC::get('systems');
    $content = '';
    $id = 1;
    for my $system (@$syslist) {
        if ($id < 10) {
             $hostname = $cfg->{snas_clustername}."_0".$id;
        } else {
             $hostname = $cfg->{snas_clustername}."_".$id;
        }

        if ($prod->{netproto} eq $prod->{netprotoipv4}) {
            $content .= "$hostname 0.0.0.0/0 $cfg->{snas_defgateway} - -\n";
        } else {
            $content .= "$hostname ::/0 $cfg->{snas_defgateway} - -\n";
        }
        $id++;
    }
    $sys->writefile($content,$prod->{nicconf}->{globalroutes});
}


sub update_hosts_file_sys {
    my ($prod,$sys,@vars) = (@_);
    my ($hostsfile,$content);
    $hostsfile = $prod->{hostsfile};
    $sys->cmd("_cmd_sed -i '/$sys->{sys}/d' $hostsfile 2>/dev/null");
    for my $line(@vars) {
        $content .= "$line\n";
    }
    $sys->appendfile($content,$hostsfile);
    return 1;
}

sub get_next_ip {
    my ($prod,$ip,$step) = @_;
    my (@nip,$iparr);
    if (!(EDRu::ip_is_ipv4($ip)) && !(EDRu::ip_is_ipv6($ip))) {
        return "0.0.0.0";    
    }
    if (EDRu::ip_is_ipv4($ip)) {
        @nip = split(/\./,$ip);
        $nip[3]+=$step;
        if ($nip[3]>255) {
            $nip[2] += ($nip[3] - 255);
            $nip[3] -= 255;
        }
        if ($nip[2]>255) {
            $nip[1] += ($nip[2] - 255);
            $nip[2] -= 255;
        }
        if ($nip[1]>255) {
            $nip[0] += ($nip[1] - 255);
            $nip[1] -= 255;
        }
        if ($nip[0]>255) {
            return "0.0.0.0";
        }
        $ip = $nip[0].".".$nip[1].".".$nip[2].".".$nip[3];
    } else {
        $iparr = EDRu::ipv6toarr($ip);
        @nip = @{$iparr};
        $nip[7]=EDRu::hex2dec($nip[7]);
        $nip[6]=EDRu::hex2dec($nip[6]);
        $nip[5]=EDRu::hex2dec($nip[5]);
        $nip[4]=EDRu::hex2dec($nip[4]);
        $nip[3]=EDRu::hex2dec($nip[3]);
        $nip[2]=EDRu::hex2dec($nip[2]);
        $nip[1]=EDRu::hex2dec($nip[1]);
        $nip[0]=EDRu::hex2dec($nip[0]);

        $nip[7]+=$step;

        if ($nip[7] > 65535) {
            $nip[6] += ($nip[7] - 65535);
            $nip[7] -= 65535;
        }

        if ($nip[6] > 65535) {
            $nip[5] += ($nip[6] - 65535);
            $nip[6] -= 65535;
        }
        if ($nip[5] > 65535) {
            $nip[4] += ($nip[5] - 65535);
            $nip[5] -= 65535;
        }

        if ($nip[4] > 65535) {
            $nip[3] += ($nip[4] - 65535);
            $nip[4] -= 65535;
        }
        if ($nip[3] > 65535) {
            $nip[2] += ($nip[3] - 65535);
            $nip[3] -= 65535;
        }
        if ($nip[2] > 65535) {
            $nip[1] += ($nip[2] - 65535);
            $nip[2] -= 65535;
        }
        if ($nip[1] > 65535) {
            $nip[0] += ($nip[1] - 65535);
            $nip[1] -= 65535;
        }
        if ($nip[0] > 65535) {
            return "0:0:0:0:0:0:0:0";
        }

        $nip[7] = EDRu::dec2hex($nip[7]);
        $nip[6] = EDRu::dec2hex($nip[6]);
        $nip[5] = EDRu::dec2hex($nip[5]);
        $nip[4] = EDRu::dec2hex($nip[4]);
        $nip[3] = EDRu::dec2hex($nip[3]);
        $nip[2] = EDRu::dec2hex($nip[2]);
        $nip[1] = EDRu::dec2hex($nip[1]);
        $nip[0] = EDRu::dec2hex($nip[0]);

        $ip = "$nip[0]:$nip[1]:$nip[2]:$nip[3]:$nip[4]:$nip[5]:$nip[6]:$nip[7]";
    }
    return $ip;
}

sub get_next_mask {
    my ($prod,$ip,$step) = @_;
    return $ip;
}

sub truncate_ip_pool {
    my ($prod) = @_;
    my $cfg= Obj::cfg();
    @{$cfg->{snas_ip_pool}->{public}} = ();
    @{$cfg->{snas_ip_pool}->{private}} = ();
    @{$cfg->{snas_nmask_pool}->{public}} = ();
    @{$cfg->{snas_nmask_pool}->{private}} = ();
    return 1;
}

sub set_ip_to_ppool {
    my ($prod,$ip) = @_;
    my $cfg = Obj::cfg();
    push (@{$cfg->{snas_ip_pool}->{public}},$ip);
    return;
}

sub get_ip_from_ppool{
    my ($prod) = @_;
    my $cfg = Obj::cfg();
    my $ip = shift @{$cfg->{snas_ip_pool}->{public}};
    return $ip;
}

sub set_ip_to_vpool {
    my ($prod,$ip) = @_;
    my $cfg = Obj::cfg();
    push (@{$cfg->{snas_ip_pool}->{private}},$ip);
    return;
}

sub get_ip_from_vpool{
    my ($prod) = @_;
    my $cfg = Obj::cfg();
    my $ip = shift @{$cfg->{snas_ip_pool}->{private}};
    return $ip;
}

sub set_nmask_to_ppool {
    my ($prod,$ip) = @_;
    my $cfg = Obj::cfg();
    push (@{$cfg->{snas_nmask_pool}->{public}},$ip);
    return;
}

sub get_nmask_from_ppool {
    my ($prod) = @_;
    my $cfg = Obj::cfg();
    my $ip = shift @{$cfg->{snas_nmask_pool}->{public}};
    return $ip;
}

sub set_nmask_to_vpool {
    my ($prod,$ip) = @_;
    my $cfg = Obj::cfg();
    push (@{$cfg->{snas_nmask_pool}->{private}},$ip);
    return;
}

sub get_nmask_from_vpool{
    my ($prod) = @_;
    my $cfg = Obj::cfg();
    my $ip = shift @{$cfg->{snas_nmask_pool}->{private}};
    return $ip;
}

sub ask_pip_sys {
    my ($prod,$sys)=@_;
    my ($answer,$backopt,$done,$msg,$help);

    $done=0;
    $backopt='';
    while (!$done) {
        $help=Msg::new("The public IP address is used for detecting the public and private NICs, and system IP addresses will be defined sequentially starting with the initial address.\nEnter the first or starting physical IP address from the range of physical IP addresses that your network administrator provided. These IP addresses must be in a consecutive numerical range.");
        $msg=Msg::new("Enter the public IP starting address:");

        $answer=$msg->ask('',$help,$backopt);

        if (!EDRu::isip($answer) || !$prod->check_ip_available($sys,$answer)) {
            $msg=Msg::new("$answer contains invalid IP address");
            $msg->print;
            next; 
        }
        $done=1;
    }
    return $answer;
}

sub ask_pnmask_sys {
    my ($prod,$sys,$hint)=@_;
    my ($answer,$backopt,$done,$msg,$help);

    $done=0;
    $backopt='';
    while (!$done) {
        $help=Msg::new("The netmask is common for physical and virtual IP addresses.");
        $msg=Msg::new("Enter the netmask for the public IP address:");

        $answer=$msg->ask($hint,$help,$backopt);

        if (!EDRu::isip($answer)) {
            $msg=Msg::new("$answer contains invalid IP address");
            $msg->print;
            next; 
        }
        $done=1;
    }
    return $answer;
}

sub ask_vip_sys {
    my ($prod,$sys)=@_;
    my ($answer,$backopt,$done,$msg,$help,$hintvip);

    $done=0;

    while (!$done) {
        $help=Msg::new("Enter the first or starting virtual IP address from the range of virtual IP addresses that your network administrator provided. These IP addresses must be in a consecutive numerical range.");
        $msg=Msg::new("Enter the virtual IP starting address:");
        $hintvip='';

        $answer=$msg->ask($hintvip,$help,$backopt);

        return $answer if (EDR::getmsgkey($answer,'back'));
        if ((!EDRu::ip_is_ipv4($answer) && ($prod->{netproto} eq $prod->{netprotoipv4})) || (!EDRu::ip_is_ipv6($answer) && ($prod->{netproto} eq $prod->{netprotoipv6})) || !EDRu::isip($answer) || !$prod->check_ip_available($sys,$answer)) {
            $msg=Msg::new("$answer contains invalid IP address");
            $msg->print;
            next; 
        }
        $done=1;
    }

    if (EDRu::ip_is_ipv4($answer)) {
        $prod->{netprotovip} = $prod->{netprotoipv4}; 
    } else {
        $prod->{netprotovip} = $prod->{netprotoipv6}; 
    }
    return $answer;
}

sub ask_vnmask_sys {
    my ($prod,$sys,$hintvnmask)=@_;
    my ($answer,$backopt,$done,$msg,$help);

    $done=0;
    $backopt='';
    while (!$done) {
        $help=Msg::new("The netmask is common for physical and virtual IP addresses.");
        $msg=Msg::new("Enter the netmask for the virtual IP address:");
        if ($hintvnmask eq "0.0.0.0" ) {
            $hintvnmask = '';
        }
        $answer=$msg->ask($hintvnmask,$help,$backopt);
        if (!EDRu::isip($answer)) {
            $msg=Msg::new("$answer contains invalid IP address");
            $msg->print;
            next; 
        }
        $done=1;
    }
    return $answer;
}

sub ask_clustername {
    my ($prod)=@_;
    my ($vcs,$answer,$backopt,$done,$msg,$help);
    $vcs=$prod->prod('VCS61');

    $done=0;
    $backopt='';
    while (!$done) {
        $help=Msg::new("The cluster name is used in the configuration files and all the nodes will be renamed as clustername_01, clustername_02 and so on in Storage NAS cluster.");
        $msg=Msg::new("Enter the Storage NAS Cluster name:");
        $answer=$msg->ask('',$help,$backopt);
        return $answer if (EDR::getmsgkey($answer,'back'));
        next if (!$vcs->verify_clustername($answer));
        $done=1;
    }
    return $answer;
}

sub ask_default_gateway_sys {
    my ($prod,$sys,$netproto)=@_;
    my ($answer,$backopt,$done,$msg,$help,$locgateway,$padv);

    $padv=$sys->padv;
    $locgateway = $padv->get_gateway_sys($sys,$prod->{netproto});
    $locgateway = '' if ($prod->{netproto} eq $prod->{netprotoipv6} && !EDRu::ip_is_ipv6($locgateway));
    $done=0;
    $backopt='';
    while (!$done) {
        $help=Msg::new("The IP address for the default gateway.");
        $msg=Msg::new("Enter the default gateway IP address:");
        $answer=$msg->ask($locgateway,$help,$backopt);
        if ((!EDRu::ip_is_ipv4($answer) && ($prod->{netproto} eq $prod->{netprotoipv4})) || (!EDRu::ip_is_ipv6($answer) && ($prod->{netproto} eq $prod->{netprotoipv6}))) {
            $msg=Msg::new("$answer contains invalid IP address");
            $msg->print;
            next; 
        }          
        $done=1;
    }    
    return $answer;
} 

sub ask_dnsip_sys {
    my ($prod,$sys)=@_;
    my ($padv,$answer,$backopt,$done,$msg,$help,$localdns);

    $padv=$sys->padv;
    $localdns = $padv->get_dns_sys($sys);

    $localdns = '' if (($prod->{netproto} eq $prod->{netprotoipv6} && !EDRu::ip_is_ipv6($localdns)) || ($prod->{netproto} eq $prod->{netprotoipv4} && !EDRu::ip_is_ipv4($localdns)));
    $done=0;
    $backopt='';
    while (!$done) {
        $help=Msg::new("The IP address for the Domain Name System (DNS) server.");
        $msg=Msg::new("Enter the DNS IP address:");
        $answer=$msg->ask($localdns,$help,$backopt);

        if ((!EDRu::ip_is_ipv4($answer) && ($prod->{netproto} eq $prod->{netprotoipv4})) || (!EDRu::ip_is_ipv6($answer) && ($prod->{netproto} eq $prod->{netprotoipv6}))) {
            $msg=Msg::new("$answer contains invalid IP address");
            $msg->print;
            next; 
        }        
        $done=1;
    }    
    return $answer;
} 

sub ask_dnsdomainname_sys {
    my ($prod,$sys)=@_;
    my ($padv,$answer,$backopt,$done,$msg,$help,$localdomain);

    $padv=$sys->padv;
    $localdomain = $padv->get_domain_sys($sys);

    $done=0;
    $backopt='';
    while (!$done) {
        $help=Msg::new("The DNS domain name is used for set it as the default for all the nodes in Storage NAS Cluster.");
        $msg=Msg::new("Enter the DNS domain Name:");
        $answer=$msg->ask($localdomain,$help,$backopt);
        return $answer if (EDR::getmsgkey($answer,'back'));
        if ($answer  eq '') {
            $msg=Msg::new("$answer is null");
            $msg->print;
            next; 
        }          
        $done=1;
    }    
    return $answer;
} 

sub ask_consoleip {
    my ($prod)=@_;
    my ($answer,$backopt,$done,$msg,$help);

    $done=0;
    $backopt='';
    while (!$done) {
        $help=Msg::new("The virtual IP address for the cluster management console.");
        $msg=Msg::new("Enter the console virtual IP address:");
        $answer=$msg->ask('',$help,$backopt);
        if ((!EDRu::ip_is_ipv4($answer) && ($prod->{netproto} eq $prod->{netprotoipv4})) || (!EDRu::ip_is_ipv6($answer) && ($prod->{netproto} eq $prod->{netprotoipv6}))) {
            $msg=Msg::new("$answer contains invalid IP address");
            $msg->print;
            next; 
        }        
        $done=1;
    }    
    return $answer;
}

sub ask_pciexclusionid_option {
    my ($prod)=@_;
    my ($answer,$backopt,$ayn,$msg,$help);
        Msg::n();
        $msg = Msg::new("Do you want to exclude NICs by PCI IDs?");
        $ayn = $msg->aynn;
        if ($ayn eq 'N') {
            return 0;
        }
        return 1;
}

sub ask_pciexclusionid {
    my ($prod)=@_;
    my ($answer,$backopt,$done,$msg,$help);

    $done=0;
    $backopt='';
    while (!$done) {
        $help=Msg::new("The PCI ID for PCI exclusion is used for skipping the detection and configuration on the NIC which is specified with PCI ID for exclusion.");
        $msg=Msg::new("Enter the PCI IDs for PCI exclusion:");
        $answer=$msg->ask('',$help,$backopt);
        if (!$prod->check_pciid_available($answer)) {
            $msg=Msg::new("$answer contains invalid PCI ID");
            $msg->print;
            next;
        }
        $done=1;
    }    
    return $answer;
} 

sub ask_pipprefix{
    my ($prod,$hint)=@_;
    my ($answer,$backopt,$done,$msg,$help);

    $done=0;
    $backopt='';
    while (!$done) {
        $help=Msg::new("The netmask is common for physical and virtual IP addresses.");
        $msg=Msg::new("Enter the prefix for public IP address:");

        $answer=$msg->ask($hint,$help,$backopt);

        if (!EDRu::isint($answer) || $answer > 128 || $answer < 1) {
            $msg=Msg::new("$answer contains invalid IPV6 Prefixlength");
            $msg->print;
            next; 
        }
        $done=1;
    }
    return $answer;
}

sub ask_nvip {
    my ($prod,$hint)=@_;
    my ($answer,$backopt,$done,$msg,$help);

    $done=0;
    $backopt='';
    while (!$done) {
        $help=Msg::new("The netmask is common for physical and virtual IP addresses.");
        $msg=Msg::new("Enter the number of VIPs per interface:");

        $answer=$msg->ask($hint,$help,$backopt);

        if (!EDRu::isint($answer) || $answer <= 0 || $answer >= 10) {
            $msg=Msg::new("$answer contains invalid number of VIPs per interface");
            $msg->print;
            next; 
        }
        $done=1;
    }
    return $answer;
}

sub ask_sep_console_port {
    my ($prod)=@_;
    my ($answer,$backopt,$done,$msg,$help,$hint);

    $done=0;
    $backopt='';
    $hint="0";
    while (!$done) {
        $help=Msg::new("The seperate console port");
        $msg=Msg::new("Enter the seperate console port:");

        $answer=$msg->ask($hint,$help,$backopt);

        if ($answer ne "0" && $answer ne "1") {
            $msg=Msg::new("$answer contains invalid seperate console port");
            $msg->print;
            next; 
        }
        $done=1;
    }
    return $answer;
}

sub poststart_sys {
    my ($prod,$sys) = @_;
    my ($vcs,$sysname);

    $vcs = $prod->prod('VCS61');
    $prod->SUPER::poststart_sys($sys);
    if ($sys->system1) {
        $sys->cmd("$prod->{installerdir}/installer -m master 2>/dev/null");
        $prod->copy_conf_to_othernodes($sys);
        $sysname = $vcs->get_vcs_sysname_sys($sys);
        $sys->cmd("_cmd_hares -wait 'Apache_Server' State ONLINE -sys $sysname -time 120");
        EDRu::create_flag('snas_configure_done');
    } else {
        EDRu::wait_for_flag('snas_configure_done');
        $sys->cmd("$prod->{installerdir}/installer -m join 2>/dev/null");
    }
    return;
}

sub copy_conf_to_othernodes {
    my ($prod,$sys) = @_;
    my ($filepath,$tmptarfile,$syslist,$sysobj);

    $filepath = $prod->{nicconf}->{filepath};
    $tmptarfile = "$filepath/conf.tar";
    $sys->cmd("cd $filepath; _cmd_tar --exclude=\"version.conf\" -cvf $tmptarfile *");
    
    $syslist = CPIC::get('systems');
    for my $system (@$syslist) {
        next if ($system->{sys} eq $sys->{sys});
        $sys->copy_to_sys($system,$tmptarfile,$tmptarfile);
        $system->cmd("cd $filepath; _cmd_tar -xvf $tmptarfile && _cmd_rmr $tmptarfile 2>/dev/null");
    }
    $sys->cmd("cd $filepath; _cmd_rmr $tmptarfile 2>/dev/null");
    return;
}

sub install_thirdparty_pkgs_sys {
    my ($prod,$sys, $thirdpartypkgs_aref) = (@_);
    my ($cpic,$file,$guirpm_dir,$iof,$msg,$rpm,$ret,$tmpdir);
    $cpic = Obj::cpic();
    $guirpm_dir = $prod->{gui_rpm_dir};
    $tmpdir=EDR::tmpdir();

    Msg::log("Installing perl template rpms on $sys->{sys}");
    if (!-d "$cpic->{mediapath}/$guirpm_dir") {
        Msg::log("No $guirpm_dir dir exists, do not install the perl-Template rpm");
        return;
    }
    for my $pkg_ver(@$thirdpartypkgs_aref) {
        my ($pkg,$ver) = split(/\s+/, $pkg_ver);
        $file = EDR::cmd_local("_cmd_ls $cpic->{mediapath}/$guirpm_dir/$pkg* 2>/dev/null");
        chomp($file);
        if (!-f $file) {
            Msg::log("No $file exists, do not install the perl-Template rpm");
            next;
        }
        $msg = Msg::new("Installing $pkg on $sys->{sys}");
        $msg->left;
        $rpm = ($sys->{islocal}) ? $file : "$tmpdir/". EDRu::basename($file);
        $prod->localsys->copy_to_sys($sys,$file,$tmpdir) if (!$sys->{islocal});
        $iof=EDRu::outputfile('install', $sys->{sys}, EDRu::basename($file));
        $sys->cmd("_cmd_rpm -U -v --nodeps $rpm 2>$iof 1>&2");
        if (EDR::cmdexit()) {
            $msg->right_failed;
        } else {
            $msg->right_done;
            $ret = 1;
        }
    }

    return $ret;
}

sub postinstall_sys {
    my ($prod,$sys) = (@_);
    my (@files,$cpic,$guirpm_dir);
    $cpic = Obj::cpic();

    if ($sys->{store_release_imgs}{base_img}) {
        $prod->copy_img_to_sys($sys, 'base');
        delete $sys->{store_release_imgs}{base_img};
    }
    if ($sys->{store_release_imgs}{mr_img}) {
        $prod->copy_img_to_sys($sys, 'mr');
        delete $sys->{store_release_imgs}{mr_img};
    }
    if ($sys->{store_release_imgs}{hf_img}) {
        $prod->copy_img_to_sys($sys, 'hf');
        delete $sys->{store_release_imgs}{hf_img};
    }
    $prod->del_obsoloted_img_sys($sys);
    $prod->update_preference_file_sys($sys);

    $guirpm_dir = $prod->{gui_rpm_dir};

    Msg::log("Copying gui jar files and tar files on $sys->{sys}");
    if (!-d "$cpic->{mediapath}/$guirpm_dir") {
        Msg::log("No $guirpm_dir dir exists, do not copy the gui tar files");
        return;
    }
    $sys->mkdir($prod->{gui_lib_dir});
    $sys->mkdir($prod->{gui_install_dir});
    @files = glob("$cpic->{mediapath}/$guirpm_dir/*");
    for my $file(@files) {
        if ($file =~ /\.jar/m) {
            $prod->localsys->copy_to_sys($sys,$file,$prod->{gui_lib_dir});
        } elsif ($file =~ /\.tar/m) {
            Msg::log("Copying $file to $prod->{gui_install_dir}");
            $prod->localsys->copy_to_sys($sys,$file,$prod->{gui_install_dir});
        }
    }

    $prod->perform_task_sys($sys,'postinstall_sys');
    return;
}

sub create_responsefile {
    my ($prod, $cfg, $resfile) = @_;
    my $rf;
    my $syslist;

    $syslist = CPIC::get('systems');
    my @systems;
    for my $system (@$syslist) {
        push(@systems, $system->{sys});
    }

    $cfg->{opt}{install} = 1;
    $cfg->{opt}{gco} = 1;
    $cfg->{opt}{accepteula} = 1;
    $cfg->{opt}{installallpkgs} = 1;
    $cfg->{opt}{noipc} = 1;
    $cfg->{opt}{updatekeys} = 1;
    $cfg->{opt}{vxkeyless} = 1;
    $cfg->{prod} = "SNAS60";
    $cfg->{systems} = \@systems;

    $rf="#\n# Configuration Values:\n#\nour \%CFG;\n\n".EDRu::hash2def($cfg, 'CFG')."\n1;\n";

    EDRu::writefile($rf, "$resfile");

    return 1;
}

sub addnode_install_sys {
    my ($prod, $sys) = @_;
    my ($repository_path, $base_version, $mr_version, $hf_version, $base_path, $mr_path, $hf_path);
    my ($basecmd, $hfcmd, $cmd, $msg, $syslist);
    my $tmpdir = EDR::get('tmpdir');
    my $resfile = "$tmpdir/addnode_install.res";
    my $localsys = Obj::edr()->{localsys};
    my $cfg;

    $prod->read_preference_file_sys($localsys);
    $repository_path = $prod->get_repository_on_sys($localsys);

    if ($localsys->{store_release_imgs}{"InstalledBase"}) {
        $base_version = $localsys->{store_release_imgs}{"InstalledBase"};
        $base_path = "$repository_path/ga/images/SSNAS/$base_version";
        if (!$prod->img_stored_on_sys($localsys, $base_path)) {
            $msg = Msg::new("SNAS $base_version is not stored on $localsys->{sys}, can not install SNAS $base_version on $sys->{sys}");
            $msg->die();
        }
    } 
    if ($localsys->{store_release_imgs}{"InstalledMR"}) {
        $mr_version = $localsys->{store_release_imgs}{"InstalledMR"};
        $mr_path = "$repository_path/mr/images/SSNAS/$mr_version";
        if (!$prod->img_stored_on_sys($localsys, $mr_path)) {
            $msg = Msg::new("SNAS $mr_version is not stored on $localsys->{sys}, can not install SNAS $mr_version on $sys->{sys}");
            $msg->die();
        }
    }
    if ($localsys->{store_release_imgs}{"InstalledHF"}) {
        $hf_version = $localsys->{store_release_imgs}{"InstalledHF"};
        $hf_path = "$repository_path/hf/images/SSNAS/$hf_version";
        if (!$prod->img_stored_on_sys($localsys, $hf_path)) {
            $msg = Msg::new("SNAS $hf_version is not stored on $localsys->{sys}, can not install SNAS $hf_version on $sys->{sys}");
            $msg->die();
        }
    }

    if ($mr_version) {
        if ($base_version) {
            $cfg->{base_path} = $base_path;
        }
        if ($hf_version) {
            $cfg->{hotfix_path} = $hf_path;
        }
        $cmd = "$mr_path/installmr";
    } elsif ($base_version) {
        if ($hf_version) {
            $cfg->{hotfix_path} = $hf_path;
        }
        $cmd = "$base_path/installer";
    } else {
        Msg::die("No base or Maintenance release installed on $localsys->{sys}");
    }

    $prod->create_responsefile($cfg, $resfile);

    $cmd .= " -responsefile $resfile";

    $msg=Msg::new("\nExecuting the following command to start installation of SNAS on $sys->{sys}:\n\n\t$cmd\n");
    $msg->bold();

    system($cmd);
}

# set up passwordless communication for root between the systems
sub ssh_com_setup {
    my ($prod, $systems_aref) = (@_);
    my (@systems,@keyfiles,$homedir);
    my ($keyfile,$keyfile_public,$knownhosts,$sshkey,$sshkeys);

    $homedir = '/root';
    @systems = @$systems_aref;
    @keyfiles=();
    $keyfile = Cfg::opt('keyfile');
    push(@keyfiles, $keyfile) if ($keyfile);
    push(@keyfiles, "$homedir/.ssh/id_rsa");
    push(@keyfiles, "$homedir/.ssh/id_dsa");

    $sshkeys = '';
    $knownhosts = '';
    for my $sys(@systems) {
        $sys->cmd("/etc/init.d/sshd start");

        $keyfile='';
        $keyfile_public='';
        for my $file (@keyfiles) {
            if ($sys->exists($file) && $sys->exists("$file".'.pub')) {
                $keyfile=$file;
                $keyfile_public="$file".'.pub';
                last;
            }
        }
        if (!$keyfile) {
            Msg::log("No existing ssh keyfile on $sys->{sys}, generate new keys");
            $keyfile="$homedir/.ssh/id_rsa";
            $keyfile_public=$keyfile.'.pub';
            $sys->cmd("_cmd_sshkeygen -q -t rsa -N \'\' -f $keyfile 2>/dev/null");
        }

        if ($sys->exists("$keyfile")) {
            $sshkey = $sys->readfile($keyfile_public);
            $sshkeys .= "$sshkey";
        }
        $knownhosts.= "$sys->{sys} ";
    }

    for my $sys(@systems) {
        Msg::log("Adding all ssh keys to authorized_keys on $sys->{sys} and generate entries in known_hosts file");
        $sys->appendfile($sshkeys, "$homedir/.ssh/authorized_keys");
        $sys->cmd("_cmd_sshkeyscan -t rsa $knownhosts > $homedir/.ssh/known_hosts 2>/dev/null");
    }

    # set comsetup option so that it will not be cleaned up
    Cfg::set_opt('comsetup');

    return;
}

package Prod::SNAS60::SunOS;
@Prod::SNAS60::SunOS::ISA = qw(Prod::SNAS60::Common);

1;
